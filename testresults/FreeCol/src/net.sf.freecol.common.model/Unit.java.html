<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>Unit.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">src (1) (May 16, 2018 4:05:44 PM)</a> &gt; <a href="../../index.html" class="el_group">FreeCol</a> &gt; <a href="../index.html" class="el_bundle">src</a> &gt; <a href="index.source.html" class="el_package">net.sf.freecol.common.model</a> &gt; <span class="el_source">Unit.java</span></div><h1>Unit.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">/**</span>
 *  Copyright (C) 2002-2015   The FreeCol Team
 *
 *  This file is part of FreeCol.
 *
 *  FreeCol is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  FreeCol is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with FreeCol.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */

package net.sf.freecol.common.model;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.function.ToIntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.logging.Logger;

import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;

import net.sf.freecol.common.i18n.Messages;
import net.sf.freecol.common.io.FreeColXMLReader;
import net.sf.freecol.common.io.FreeColXMLWriter;
import net.sf.freecol.common.model.CombatModel;
import net.sf.freecol.common.model.Direction;
import net.sf.freecol.common.model.pathfinding.CostDecider;
import net.sf.freecol.common.model.pathfinding.CostDeciders;
import net.sf.freecol.common.model.pathfinding.GoalDecider;
import net.sf.freecol.common.model.pathfinding.GoalDeciders;
import net.sf.freecol.common.model.UnitTypeChange.ChangeType;
import static net.sf.freecol.common.util.CollectionUtils.*;
import static net.sf.freecol.common.util.StringUtils.*;


import org.w3c.dom.Element;


/**
 * Represents all pieces that can be moved on the map-board. This includes:
 * colonists, ships, wagon trains e.t.c.
 *
 * Every &lt;code&gt;Unit&lt;/code&gt; is owned by a {@link Player} and has a
 * {@link Location}.
 */
public class Unit extends GoodsLocation
    implements Consumer, Locatable, Movable, Nameable, Ownable {

<span class="fc" id="L63">    private static final Logger logger = Logger.getLogger(Unit.class.getName());</span>

    /**
     * A large number of turns, denoting pathfinding failure.  Do not use
     * INFINITY as further calculation might use this.
     */
    public static final int MANY_TURNS = 10000;

    public static final String CARGO_CHANGE = &quot;CARGO_CHANGE&quot;;
    public static final String MOVE_CHANGE = &quot;MOVE_CHANGE&quot;;
    public static final String ROLE_CHANGE = &quot;ROLE_CHANGE&quot;;

    /**
     * A comparator to compare units by position, top to bottom,
     * left to right.
     */
<span class="fc" id="L79">    public static final Comparator&lt;Unit&gt; locComparator</span>
<span class="fc" id="L80">        = Comparator.comparingInt(u -&gt; Location.getRank(u));</span>

    /** A comparator to compare units by type then role. */
<span class="fc" id="L83">    public static final Comparator&lt;Unit&gt; typeRoleComparator</span>
<span class="fc" id="L84">        = Comparator.comparing(Unit::getType)</span>
<span class="fc" id="L85">            .thenComparing(Comparator.comparing(Unit::getRole));</span>
    
    /** A state a Unit can have. */
<span class="fc" id="L88">    public static enum UnitState {</span>
<span class="fc" id="L89">        ACTIVE,</span>
<span class="fc" id="L90">        FORTIFIED,</span>
<span class="fc" id="L91">        SENTRY,</span>
<span class="fc" id="L92">        IN_COLONY,</span>
<span class="fc" id="L93">        IMPROVING,</span>
<span class="fc" id="L94">        // @compat 0.10.0</span>
<span class="fc" id="L95">        TO_EUROPE,</span>
<span class="fc" id="L96">        TO_AMERICA,</span>
<span class="fc" id="L97">        // end @compat</span>
<span class="fc" id="L98">        FORTIFYING,</span>
<span class="fc" id="L99">        SKIPPED;</span>

        /**
         * Get the stem key for this unit state.
         *
         * @return The stem key.
         */
        public String getKey() {
<span class="nc" id="L107">            return &quot;unitState.&quot; + getEnumKey(this);</span>
        }
    }

    /** The individual name of this unit, not of the unit type. */
<span class="fc" id="L112">    protected String name = null;</span>

    /** The owner player. */
    protected Player owner;

    /** The unit type. */
    protected UnitType unitType;

    /** Current unit state. */
<span class="fc" id="L121">    protected UnitState state = UnitState.ACTIVE;</span>

    /** Current unit role. */
    protected Role role;

    /**
     * The amount of role-equipment this unit carries, subject to
     * role.getMaximumCount().  Currently zero or one except for pioneers.
     */
    protected int roleCount;

    /** The current unit location. */
    protected Location location;

    /** The last entry location used by this unit. */
    protected Location entryLocation;

    /** The number of moves this unit has left this turn. */
    protected int movesLeft;

    /** What type of goods this unit produces in its occupation. */
    protected GoodsType workType;

    /** What type of goods this unit last earned experience producing. */
    protected GoodsType experienceType;

    /** The mount of experience a unit has earned. */
<span class="fc" id="L148">    protected int experience = 0;</span>

    /**
     * The number of turns until the work is finished (e.g. sailing,
     * improving), or '-1' if a Unit can stay in its state forever.
     */
    protected int workLeft;

    /**
     * What is being improved (to be used only for PIONEERs - where
     * they are working.
     */
    protected TileImprovement workImprovement;

    /** The student of this Unit, if it has one. */
    protected Unit student;

    /** The teacher of this Unit, if it has one. */
    protected Unit teacher;

    /** Number of turns of training needed by this unit. */
<span class="fc" id="L169">    protected int turnsOfTraining = 0;</span>

    /** The original nationality. */
<span class="fc" id="L172">    protected String nationality = null;</span>

    /** The original ethnicity. */
<span class="fc" id="L175">    protected String ethnicity = null;</span>

    /** The home settlement of a native unit. */
<span class="fc" id="L178">    protected IndianSettlement indianSettlement = null;</span>

    /** For now; only used by ships when repairing. */
    protected int hitPoints;

    /** A destination for go-to moves. */
<span class="fc" id="L184">    protected Location destination = null;</span>

    /** The trade route this unit has. */
<span class="fc" id="L187">    protected TradeRoute tradeRoute = null;</span>

    /** Which stop in a trade route the unit is going to. */
<span class="fc" id="L190">    protected int currentStop = -1;</span>

    /** To be used only for type == TREASURE_TRAIN */
    protected int treasureAmount;

    /**
     * The attrition this unit has accumulated.  At the moment, this
     * equals the number of turns it has spent in the open.
     */
<span class="fc" id="L199">    protected int attrition = 0;</span>

    /**
     * The amount of goods carried by this unit.  This variable is
     * only used by the clients.  A negative value signals that the
     * variable is not in use.
     *
     * @see #getVisibleGoodsCount()
     */
    protected int visibleGoodsCount;


    /**
     * Constructor for ServerUnit.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     */
    protected Unit(Game game) {
<span class="fc" id="L217">        super(game);</span>
<span class="fc" id="L218">    }</span>

    /**
     * Initialize this object from an XML-representation of this object.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param e An XML-element that will be used to initialize this object.
     */
    public Unit(Game game, Element e) {
<span class="fc" id="L227">        super(game, e);</span>

<span class="fc" id="L229">        readFromXMLElement(e);</span>
<span class="fc" id="L230">    }</span>

    /**
     * Creates a new &lt;code&gt;Unit&lt;/code&gt; with the given
     * identifier.  The object should later be initialized by calling
     * {@link #readFromXML(FreeColXMLReader)}.
     *
     * @param game The enclosing &lt;code&gt;Game&lt;/code&gt;.
     * @param id The object identifier.
     */
    public Unit(Game game, String id) {
<span class="fc" id="L241">        super(game, id);</span>
<span class="fc" id="L242">    }</span>


    /**
     * Get the individual name of this unit.
     *
     * @return The individual name.
     */
    @Override
    public String getName() {
<span class="fc" id="L252">        return name;</span>
    }

    /**
     * Set the individual name of this unit.
     *
     * @param newName The new name.
     */
    @Override
    public void setName(String newName) {
<span class="fc" id="L262">        this.name = newName;</span>
<span class="fc" id="L263">    }</span>

    /**
     * Get the name of the apparent owner of this Unit,
     * (like getOwner().getNationAsString() but handles pirates).
     *
     * @return The name of the apparent owner of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public StringTemplate getApparentOwnerName() {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        Player own = (hasAbility(Ability.PIRACY)) ? getGame().getUnknownEnemy()</span>
<span class="fc" id="L273">            : owner;</span>
<span class="fc" id="L274">        return own.getNationLabel();</span>
    }

    /** What type of unit label do we want? */
<span class="fc" id="L278">    public static enum UnitLabelType {</span>
<span class="fc" id="L279">        PLAIN,      // Just the basics</span>
<span class="fc" id="L280">        NATIONAL,   // Add the nation</span>
<span class="fc" id="L281">        FULL        // Add the equipment and extras</span>
    }

    /**
     * Get a plain string template for a unit.
     *
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel() {
<span class="fc" id="L290">        return getLabel(UnitLabelType.PLAIN);</span>
    }

    /**
     * Get a string template for a unit.
     *
     * The PLAIN template contains:
     * - The type of the unit
     * - A role if not the default
     * - The specific name of the unit if it has one
     * The NATIONAL template adds the nation
     * The FULL template adds equipment annotations
     *
     * @param ult The type of label to get.
     * @return The &lt;code&gt;StringTemplate&lt;/code&gt; to describe the given unit.
     */
    public StringTemplate getLabel(UnitLabelType ult) {
<span class="fc" id="L307">        final UnitType type = getType();</span>
<span class="fc" id="L308">        final Role role = getRole();</span>
<span class="fc" id="L309">        final Player owner = getOwner();</span>
<span class="pc bpc" id="L310" title="2 of 6 branches missed.">        if (type == null || role == null || owner == null) {</span>
<span class="fc" id="L311">            return null; // Probably disposed</span>
        }

<span class="pc bpc" id="L314" title="1 of 4 branches missed.">        switch (ult) {</span>
	        case PLAIN:
<span class="fc" id="L316">	            return Messages.getUnitLabel(getName(), type.getId(), 1, null,</span>
<span class="fc" id="L317">	                                         role.getId(), null);</span>
	
	        case NATIONAL:
<span class="fc bfc" id="L320" title="All 2 branches covered.">	            if (role.getMaximumCount() &lt;= 1) {</span>
	                // If the amount of equipment can vary an equipment
	                // label is required, so fall through into the FULL case.
<span class="fc" id="L323">	                return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L324">	                                             owner.getNationId(), role.getId(),</span>
<span class="fc" id="L325">	                                             null);</span>
	            }
	            // Fall through
	
	        case FULL:
<span class="fc" id="L330">	            return getLabelFullUnitType(type, role, owner);</span>
	            
	        default: // Can not happen
	            break;
        }
<span class="nc" id="L335">        return null;</span>
    }

	private StringTemplate getLabelFullUnitType(final UnitType type, final Role role, final Player owner) {
<span class="fc" id="L339">		StringTemplate extra = null;</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">		if (role.isDefaultRole()) {</span>
<span class="fc" id="L341">		    extra = getLabelDefaultRole(type, extra);</span>
<span class="fc" id="L342">		} else {</span>
<span class="fc" id="L343">		    extra = getLabelNotDefaultRole(role);</span>
		}
<span class="fc" id="L345">		return Messages.getUnitLabel(getName(), type.getId(), 1,</span>
<span class="fc" id="L346">		                             owner.getNationId(), role.getId(),</span>
<span class="fc" id="L347">		                             extra);</span>
	}

	private StringTemplate getLabelNotDefaultRole(final Role role) {
		StringTemplate extra;
<span class="fc" id="L352">		String equipmentKey = role.getId() + &quot;.equipment&quot;;</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">		if (Messages.containsKey(equipmentKey)) {</span>
		    // Currently only used for missionary which does not
		    // have equipment that directly corresponds to goods.
<span class="fc" id="L356">		    extra = AbstractGoods.getLabel(equipmentKey, 1);</span>
<span class="fc" id="L357">		} else {</span>
		    // Other roles can be characterized by their goods.
<span class="fc" id="L359">		    List&lt;AbstractGoods&gt; requiredGoods</span>
<span class="fc" id="L360">		        = role.getRequiredGoods(getRoleCount());</span>
<span class="fc" id="L361">		    boolean first = true;</span>
<span class="fc" id="L362">		    extra = StringTemplate.label(&quot;&quot;);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">		    for (AbstractGoods ag : requiredGoods) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">		        if (first) first = false; else extra.addName(&quot; &quot;);</span>
<span class="fc" id="L365">		        extra.addStringTemplate(ag.getLabel());</span>
		    }
		}
<span class="fc" id="L368">		return extra;</span>
	}

	private StringTemplate getLabelDefaultRole(final UnitType type, StringTemplate extra) {
<span class="fc bfc" id="L372" title="All 2 branches covered.">		if (canCarryTreasure()) {</span>
<span class="fc" id="L373">		    extra = StringTemplate.template(&quot;goldAmount&quot;)</span>
<span class="fc" id="L374">		        .addAmount(&quot;%amount%&quot;, getTreasureAmount());</span>
<span class="fc" id="L375">		} else {</span>
<span class="fc" id="L376">		    boolean noEquipment = false;</span>
		    // unequipped expert has no-equipment label
<span class="fc" id="L378">		    List&lt;Role&gt; expertRoles = type.getExpertRoles();</span>
<span class="fc bfc" id="L379" title="All 2 branches covered.">		    for (Role someRole : expertRoles) {</span>
<span class="fc" id="L380">		        String key = someRole.getId() + &quot;.noequipment&quot;;</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">		        if (Messages.containsKey(key)) {</span>
<span class="fc" id="L382">		            extra = StringTemplate.key(key);</span>
<span class="fc" id="L383">		            break;</span>
		        }
		    }
		}
<span class="fc" id="L387">		return extra;</span>
	}

    /**
     * Get the basic i18n description for this unit.
     *
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription() {
<span class="fc" id="L396">        return Messages.message(getLabel());</span>
    }

    /**
     * Get the basic i18n description for this unit.
     *
     * @param ult The label type required.
     * @return A &lt;code&gt;String&lt;/code&gt; describing this unit.
     */
    public String getDescription(UnitLabelType ult) {
<span class="fc" id="L406">        return Messages.message(getLabel(ult));</span>
    }

    /**
     * Get a label for the chance of success in a potential combat.
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to attack into.
     * @return A suitable label.
     */
    public StringTemplate getCombatLabel(Tile tile) {
<span class="nc" id="L416">        final CombatModel.CombatOdds combatOdds = getGame().getCombatModel()</span>
<span class="nc" id="L417">            .calculateCombatOdds(this, tile.getDefendingUnit(this));</span>
        // If attacking a settlement, the true odds are never
        // known because units may be hidden within
<span class="nc bnc" id="L420" title="All 2 branches missed.">        boolean unknown = combatOdds.win == CombatModel.CombatOdds.UNKNOWN_ODDS</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">            || tile.hasSettlement();</span>
<span class="nc" id="L422">        return StringTemplate.template(&quot;model.unit.attackTileOdds&quot;)</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">            .addName(&quot;%chance%&quot;, (unknown) ? &quot;??&quot;</span>
<span class="nc" id="L424">                : String.valueOf((int)(combatOdds.win * 100)));</span>
    }
    
    /**
     * Get a destination label for this unit.
     *
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing where this unit
     *     is going.
     */
    public StringTemplate getDestinationLabel() {
        // Create the right tag for the tagged &quot;goingTo&quot; message.
<span class="nc bnc" id="L435" title="All 2 branches missed.">        String type = (isPerson()) ? &quot;person&quot;</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            : (isNaval()) ? &quot;ship&quot;</span>
<span class="nc" id="L437">            : &quot;other&quot;;</span>
<span class="nc" id="L438">        return getDestinationLabel(type, getDestination(), getOwner());</span>
    }

    /**
     * Get a destination label for a given unit tag, destination and player.
     *
     * @param tag The unit tag for the &quot;goingTo&quot; message.
     * @param destination The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewpoint.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; describing the unit movement.
     */
    public static StringTemplate getDestinationLabel(String tag,
        Location destination, Player player) {
<span class="nc" id="L451">        return StringTemplate.template(&quot;model.unit.goingTo&quot;)</span>
<span class="nc" id="L452">            .add(&quot;%type%&quot;, tag)</span>
<span class="nc" id="L453">            .addStringTemplate(&quot;%location%&quot;,</span>
<span class="nc" id="L454">                destination.getLocationLabelFor(player));</span>
    }

    /**
     * Get a string template describing the repair state of this unit.
     *
     * @return A repair label.
     */
    public StringTemplate getRepairLabel() {
<span class="nc" id="L463">        return StringTemplate.template(&quot;model.unit.underRepair&quot;)</span>
<span class="nc" id="L464">            .addAmount(&quot;%turns%&quot;, getTurnsForRepair());</span>
    }

    /**
     * Get the &lt;code&gt;UnitType&lt;/code&gt; value.
     *
     * @return The current &lt;code&gt;UnitType&lt;/code&gt;.
     */
    public final UnitType getType() {
<span class="fc" id="L473">        return unitType;</span>
    }

    /**
     * Sets the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     */
    public void setType(UnitType unitType) {
<span class="fc" id="L484">        this.unitType = unitType;</span>
<span class="fc" id="L485">    }</span>

    /**
     * Changes the type of the unit.
     *
     * -vis: Has visibility issues as the line of sight may change.
     *
     * @param unitType The new type of the unit.
     * @return True if the type change succeeds.
     */
    public boolean changeType(UnitType unitType) {
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">        if (!unitType.isAvailableTo(owner)) return false;</span>

<span class="fc" id="L498">        setType(unitType);</span>
<span class="pc bpc" id="L499" title="1 of 2 branches missed.">        if (getMovesLeft() &gt; getInitialMovesLeft()) {</span>
<span class="nc" id="L500">            setMovesLeft(getInitialMovesLeft());</span>
        }
<span class="fc" id="L502">        hitPoints = unitType.getHitPoints();</span>
<span class="fc bfc" id="L503" title="All 4 branches covered.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="fc" id="L504">            getTeacher().setStudent(null);</span>
<span class="fc" id="L505">            setTeacher(null);</span>
        }
<span class="fc" id="L507">        return true;</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is naval.
     *
     * @return True if this is a naval &lt;code&gt;Unit&lt;/code&gt;.
     */
    public boolean isNaval() {
<span class="fc bfc" id="L516" title="All 2 branches covered.">        return (unitType == null) ? false : unitType.isNaval();</span>
    }

    /**
     * Checks if this unit is an undead.
     *
     * @return True if the unit is undead.
     */
    public boolean isUndead() {
<span class="nc" id="L525">        return hasAbility(Ability.UNDEAD);</span>
    }

    /**
     * Can this unit carry treasure (like a treasure train)?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; can carry treasure.
     */
    public boolean canCarryTreasure() {
<span class="fc" id="L534">        return hasAbility(Ability.CARRY_TREASURE);</span>
    }

    /**
     * Can this unit capture enemy goods?
     *
     * @return True if this &lt;code&gt;Unit&lt;/code&gt; is capable of capturing goods.
     */
    public boolean canCaptureGoods() {
<span class="fc" id="L543">        return hasAbility(Ability.CAPTURE_GOODS);</span>
    }

    /**
     * Checks if this is a trading &lt;code&gt;Unit&lt;/code&gt;, meaning that it
     * can trade with settlements.
     *
     * @return True if this is a trading unit.
     */
    public boolean isTradingUnit() {
<span class="fc bfc" id="L553" title="All 4 branches covered.">        return canCarryGoods() &amp;&amp; owner.isEuropean();</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is a `colonist'.  A unit is a
     * colonist if it is European and can build a new &lt;code&gt;Colony&lt;/code&gt;.
     *
     * @return True if this unit is a colonist.
     */
    public boolean isColonist() {
<span class="fc bfc" id="L563" title="All 2 branches covered.">        return unitType.hasAbility(Ability.FOUND_COLONY)</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">            &amp;&amp; owner.hasAbility(Ability.FOUNDS_COLONIES);</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is able to carry {@link Locatable}s.
     *
     * @return True if this unit can carry goods or other units.
     */
    public boolean isCarrier() {
<span class="pc bpc" id="L573" title="1 of 4 branches missed.">        return unitType.canCarryGoods() || unitType.canCarryUnits();</span>
    }

    /**
     * Checks if this unit is a person, that is not a ship or wagon.
     * Surprisingly difficult without explicit enumeration because
     * model.ability.person only arrived in 0.10.1.
     *
     * @return True if this unit is a person.
     */
    public boolean isPerson() {
<span class="fc bfc" id="L584" title="All 2 branches covered.">        return hasAbility(Ability.PERSON)</span>
            // @compat 0.10.0
<span class="pc bpc" id="L586" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_COLONY)</span>
<span class="pc bpc" id="L587" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.BORN_IN_INDIAN_SETTLEMENT)</span>
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">            || unitType.hasAbility(Ability.FOUND_COLONY)</span>
            // Nick also had:
            //     &amp;&amp; (!hasAbility(&quot;model.ability.carryGoods&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryUnits&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.carryTreasure&quot;)
            //         &amp;&amp; !hasAbility(&quot;model.ability.bombard&quot;))
            // ...but that should be unnecessary.
            // end @compat
            ;
    }

    /**
     * Gets the state of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @return The state of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public UnitState getState() {
<span class="fc" id="L605">        return state;</span>
    }

    /**
     * Checks if a &lt;code&gt;Unit&lt;/code&gt; can get the given state set.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, FORTIFIED, ...}.
     * @return True if the &lt;code&gt;Unit&lt;/code&gt; state can be changed to
     *     the new value.
     */
    public boolean checkSetState(UnitState s) {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">        if (getState() == s) return false;</span>
<span class="pc bpc" id="L618" title="2 of 8 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L620">            return true;</span>
        case FORTIFIED:
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">            return getState() == UnitState.FORTIFYING;</span>
        case FORTIFYING:
<span class="pc bpc" id="L624" title="1 of 2 branches missed.">            return getMovesLeft() &gt; 0;</span>
        case IMPROVING:
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">            return getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L627" title="1 of 2 branches missed.">                &amp;&amp; location instanceof Tile</span>
<span class="pc bpc" id="L628" title="1 of 2 branches missed.">                &amp;&amp; getOwner().canAcquireForImprovement(location.getTile());</span>
        case IN_COLONY:
<span class="pc bpc" id="L630" title="1 of 2 branches missed.">            return !isNaval();</span>
        case SENTRY:
<span class="fc" id="L632">            return true;</span>
        case SKIPPED:
<span class="nc bnc" id="L634" title="All 2 branches missed.">            return getState() == UnitState.ACTIVE;</span>
        default:
<span class="nc" id="L636">            logger.warning(&quot;Invalid unit state: &quot; + s);</span>
<span class="nc" id="L637">            return false;</span>
        }
    }

    /**
     * Sets a new state for this unit and initializes the amount of
     * work the unit has left.
     *
     * If the work needs turns to be completed (for instance when
     * plowing), then the moves the unit has still left will be used
     * up. Some work (basically building a road with a hardy pioneer)
     * might actually be finished already in this method-call, in
     * which case the state is set back to UnitState.ACTIVE.
     *
     * @param s The new state for this Unit.  Should be one of
     *     {UnitState.ACTIVE, UnitState.FORTIFIED, ...}.
     */
    public void setState(UnitState s) {
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (state == s) {</span>
            // No need to do anything when the state is unchanged
<span class="fc" id="L657">            return;</span>
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">        } else if (!checkSetState(s)) {</span>
<span class="nc" id="L659">            throw new IllegalStateException(&quot;Illegal UnitState transition: &quot;</span>
<span class="nc" id="L660">                + state + &quot; -&gt; &quot; + s);</span>
        } else {
<span class="fc" id="L662">            setStateUnchecked(s);</span>
        }
<span class="fc" id="L664">    }</span>

    /**
     * Actually set the unit state.
     *
     * @param s The new &lt;code&gt;UnitState&lt;/code&gt;.
     */
    protected void setStateUnchecked(UnitState s) {
        // FIXME: move to the server.
        // Cleanup the old UnitState, for example destroy the
        // TileImprovment being built by a pioneer.
<span class="fc bfc" id="L675" title="All 2 branches covered.">        switch (state) {</span>
        case IMPROVING:
<span class="pc bpc" id="L677" title="3 of 4 branches missed.">            if (workImprovement != null &amp;&amp; getWorkLeft() &gt; 0) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">                if (!workImprovement.isComplete()</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">                    &amp;&amp; workImprovement.getTile() != null</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                    &amp;&amp; workImprovement.getTile().getTileItemContainer() != null) {</span>
<span class="nc" id="L681">                    workImprovement.getTile().getTileItemContainer()</span>
<span class="nc" id="L682">                        .removeTileItem(workImprovement);</span>
                }
<span class="nc" id="L684">                setWorkImprovement(null);</span>
            }
<span class="nc" id="L686">            break;</span>
        default:
            // do nothing
<span class="fc" id="L689">            break;</span>
        }

        // Now initiate the new UnitState
<span class="pc bpc" id="L693" title="1 of 7 branches missed.">        switch (s) {</span>
        case ACTIVE:
<span class="fc" id="L695">            setWorkLeft(-1);</span>
<span class="fc" id="L696">            break;</span>
        case SENTRY:
<span class="fc" id="L698">            setWorkLeft(-1);</span>
<span class="fc" id="L699">            break;</span>
        case FORTIFIED:
<span class="fc" id="L701">            setWorkLeft(-1);</span>
<span class="fc" id="L702">            movesLeft = 0;</span>
<span class="fc" id="L703">            break;</span>
        case FORTIFYING:
<span class="fc" id="L705">            setWorkLeft(1);</span>
<span class="fc" id="L706">            break;</span>
        case IMPROVING:
<span class="fc bfc" id="L708" title="All 2 branches covered.">            if (workImprovement == null) {</span>
<span class="fc" id="L709">                setWorkLeft(-1);</span>
<span class="fc" id="L710">            } else {</span>
<span class="fc" id="L711">                setWorkLeft(workImprovement.getTurnsToComplete()</span>
<span class="pc bpc" id="L712" title="1 of 2 branches missed.">                    + ((getMovesLeft() &gt; 0) ? 0 : 1));</span>
            }
<span class="fc" id="L714">            movesLeft = 0;</span>
<span class="fc" id="L715">            break;</span>
        case SKIPPED: // do nothing
<span class="nc" id="L717">            break;</span>
        default:
<span class="fc" id="L719">            setWorkLeft(-1);</span>
        }
<span class="fc" id="L721">        state = s;</span>
<span class="fc" id="L722">    }</span>

    /**
     * Sets the given state to all the units that are carried.
     *
     * @param state The &lt;code&gt;UnitState&lt;/code&gt; to set..
     */
    public void setStateToAllChildren(UnitState state) {
<span class="fc bfc" id="L730" title="All 2 branches covered.">        if (canCarryUnits()) {</span>
<span class="pc bpc" id="L731" title="1 of 2 branches missed.">            for (Unit u : getUnitList()) u.setState(state);</span>
        }
<span class="fc" id="L733">    }</span>

    /**
     * Change the owner of this unit.
     *
     * -vis: This routine calls setOwner() and thus has visibility
     * implications.  Ideally it should be in ServerUnit but we keep
     * it here for the benefit of the test suite.
     *
     * @param owner The new owner &lt;code&gt;Player&lt;/code&gt;.
     */
    public void changeOwner(Player owner) {
<span class="fc" id="L745">        final Player oldOwner = this.owner;</span>
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">        if (oldOwner == owner) return;</span>

<span class="pc bpc" id="L748" title="1 of 2 branches missed.">        if (oldOwner == null) {</span>
<span class="nc" id="L749">            logger.warning(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L750">                + &quot; had no owner, when changing owner to &quot; + owner.getId());</span>
        }

        // This need to be set right away.
<span class="fc" id="L754">        setOwner(owner);</span>

        // Clear trade route and goto orders if changing owner.
<span class="pc bpc" id="L757" title="1 of 2 branches missed.">        if (getTradeRoute() != null) setTradeRoute(null);</span>
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">        if (getDestination() != null) setDestination(null);</span>

        // If its a carrier, we need to update the units it has loaded
        // before finishing with it
<span class="fc bfc" id="L762" title="All 2 branches covered.">        for (Unit u : getUnitList()) u.changeOwner(owner);</span>

<span class="pc bpc" id="L764" title="3 of 4 branches missed.">        if (getTeacher() != null &amp;&amp; !canBeStudent(getTeacher())) {</span>
<span class="nc" id="L765">            getTeacher().setStudent(null);</span>
<span class="nc" id="L766">            setTeacher(null);</span>
        }

<span class="pc bpc" id="L769" title="1 of 2 branches missed.">        if (oldOwner != null) oldOwner.removeUnit(this);</span>
<span class="pc bpc" id="L770" title="1 of 2 branches missed.">        if (owner != null) owner.addUnit(this);</span>

<span class="fc" id="L772">        getGame().notifyOwnerChanged(this, oldOwner, owner);</span>
<span class="fc" id="L773">    }</span>

    /**
     * Gets the unit role.
     *
     * @return The &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Role getRole() {
<span class="fc" id="L781">        return role;</span>
    }

    /**
     * Sets the &lt;code&gt;Role&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     */
    public void setRole(Role role) {
<span class="fc" id="L790">        this.role = role;</span>
<span class="fc" id="L791">    }</span>

    /**
     * Get the role count.
     *
     * @return The current role count.
     */    
    public int getRoleCount() {
<span class="fc" id="L799">        return roleCount;</span>
    }

    /**
     * Set the role count.
     *
     * @param roleCount The new role count.
     */    
    public void setRoleCount(int roleCount) {
<span class="fc" id="L808">        this.roleCount = roleCount;</span>
<span class="fc" id="L809">    }</span>

    /**
     * Does this unit have the default role?
     *
     * @return True if the unit has the default &lt;code&gt;Role&lt;/code&gt;.
     */
    public boolean hasDefaultRole() {
<span class="fc" id="L817">        return role.isDefaultRole();</span>
    }

    /**
     * Get the last part of the role identifier, which is often used as
     * part of a message key.
     *
     * @return The role suffix.
     */
    public String getRoleSuffix() {
<span class="fc" id="L827">        return Role.getRoleSuffix(role.getId());</span>
    }

    /**
     * Change the current role of this unit.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt;.
     * @param roleCount The new role count.
     */
    public void changeRole(Role role, int roleCount) {
<span class="fc bfc" id="L837" title="All 2 branches covered.">        if (!role.isCompatibleWith(getRole())) {</span>
            // Clear experience if changing to an incompatible role.
<span class="fc" id="L839">            setExperience(0);</span>
        }
<span class="fc" id="L841">        setRole(role);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">        setRoleCount((role.isDefaultRole()) ? 0 : roleCount);</span>
<span class="fc" id="L843">    }</span>

    /**
     * Change the current role count.  On zero, revert to default role.
     *
     * @param delta The change to apply to the role count.
     * @return True if the role count reached zero.
     */
    public boolean changeRoleCount(int delta) {
<span class="fc" id="L852">        this.roleCount = Math.max(0, this.roleCount + delta);</span>
<span class="fc bfc" id="L853" title="All 2 branches covered.">        if (this.roleCount != 0) return false;</span>
<span class="fc" id="L854">        this.role = getSpecification().getDefaultRole();</span>
<span class="fc" id="L855">        return true;</span>
    }

    /**
     * Is a role available to this unit?
     *
     * @param role The &lt;code&gt;Role&lt;/code&gt; to test.
     * @return True if the role is available to this unit.
     */
    public boolean roleIsAvailable(Role role) {
<span class="fc" id="L865">        return role.isAvailableTo(this);</span>
    }

    /**
     * Filter a list of roles to return only those available to this unit.
     *
     * @param roles The list of &lt;code&gt;Role&lt;/code&gt;s to filter, if null all
     *     available roles are used.
     * @return A list of available &lt;code&gt;Role&lt;/code&gt;s.
     */
    public List&lt;Role&gt; getAvailableRoles(List&lt;Role&gt; roles) {
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">        if (roles == null) roles = getSpecification().getRoles();</span>
<span class="fc" id="L877">        return roles.stream()</span>
<span class="fc" id="L878">            .filter(r -&gt; roleIsAvailable(r)).collect(Collectors.toList());</span>
    }

    /**
     * Get a military role for this unit.
     *
     * @return A military &lt;code&gt;Role&lt;/code&gt;, or null if none found.
     */
    public Role getMilitaryRole() {
<span class="fc" id="L887">        List&lt;Role&gt; roles</span>
<span class="fc" id="L888">            = getAvailableRoles(getSpecification().getMilitaryRoles());</span>
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">        return (roles.isEmpty()) ? null : roles.get(0);</span>
    }

    /**
     * Get the change in goods required to change to a new role/count.
     *
     * @param role The new &lt;code&gt;Role&lt;/code&gt; to change to.
     * @param roleCount The new role count.
     * @return A list of &lt;code&gt;AbstractGoods&lt;/code&gt; defining the change
     *     in goods required.
     */
    public List&lt;AbstractGoods&gt; getGoodsDifference(Role role, int roleCount) {
<span class="fc" id="L901">        return Role.getGoodsDifference(getRole(), getRoleCount(),</span>
<span class="fc" id="L902">                                       role, roleCount);</span>
    }

    /**
     * Sets the units location without updating any other variables
     *
     * get/setLocation are in Locatable interface.
     *
     * -vis: This routine changes player visibility.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setLocationNoUpdate(Location newLocation) {
<span class="fc" id="L915">        location = newLocation;</span>
<span class="fc" id="L916">    }</span>

    /**
     * Verifies if the unit is aboard a carrier
     *
     * @return True if the unit is aboard a carrier.
     */
    public boolean isOnCarrier() {
<span class="fc" id="L924">        return getLocation() instanceof Unit;</span>
    }

    /**
     * Gets the carrier this unit is aboard if any.
     *
     * @return The carrier this unit is aboard, or null if none.
     */
    public Unit getCarrier() {
<span class="fc bfc" id="L933" title="All 2 branches covered.">        return (isOnCarrier()) ? ((Unit)getLocation()) : null;</span>
    }

    /**
     * Checks whether this &lt;code&gt;Unit&lt;/code&gt; is at sea off the map, or
     * on board of a carrier that is.
     *
     * @return True if at sea.
     */
    public boolean isAtSea() {
<span class="fc bfc" id="L943" title="All 2 branches covered.">        return (location instanceof Unit) ? ((Unit)location).isAtSea()</span>
<span class="fc" id="L944">            : location instanceof HighSeas;</span>
    }

    /**
     * Checks if this unit is running a mission.
     *
     * @return True if this unit is running a mission.
     */
    public boolean isInMission() {
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">        return hasAbility(Ability.ESTABLISH_MISSION)</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">            &amp;&amp; (getLocation() instanceof IndianSettlement</span>
                // @compat 0.10.x
                // Remove this when PET missionary serialization is retired
<span class="nc bnc" id="L957" title="All 2 branches missed.">                || getLocation() == null</span>
                // end @compat 0.10.x
                );
    }

    /**
     * Checks whether this unit is working inside a colony.
     *
     * @return True if in colony.
     */
    public boolean isInColony() {
<span class="fc" id="L968">        return getLocation() instanceof WorkLocation;</span>
    }

    /**
     * Is this unit on a tile?
     *
     * @return True if this unit is on a tile.
     */
    public boolean hasTile() {
<span class="fc bfc" id="L977" title="All 2 branches covered.">        return getTile() != null;</span>
    }


    /**
     * Gets the work location this unit is working in.
     *
     * @return The current &lt;code&gt;WorkLocation&lt;/code&gt;, or null if none.
     */
    public WorkLocation getWorkLocation() {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        return (isInColony()) ? (WorkLocation)getLocation() : null;</span>
    }

    /**
     * Gets the &lt;code&gt;Building&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;Building&lt;/code&gt;, or null if none.
     */
    public Building getWorkBuilding() {
<span class="nc bnc" id="L996" title="All 2 branches missed.">        if (getLocation() instanceof Building) {</span>
<span class="nc" id="L997">            return ((Building) getLocation());</span>
        }
<span class="nc" id="L999">        return null;</span>
    }

    /**
     * Gets the &lt;code&gt;ColonyTile&lt;/code&gt; this unit is working in.
     *
     * @return The current &lt;code&gt;ColonyTile&lt;/code&gt;, or null if none.
     */
    public ColonyTile getWorkTile() {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (getLocation() instanceof ColonyTile) {</span>
<span class="nc" id="L1009">            return ((ColonyTile) getLocation());</span>
        }
<span class="nc" id="L1011">        return null;</span>
    }

    /**
     * Gets the entry location for this unit to use when returning from
     * {@link Europe}.
     *
     * @return The entry &lt;code&gt;Location&lt;/code&gt;.
     */
    public Location getEntryLocation() {
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (entryLocation == null) {</span>
<span class="nc" id="L1022">            entryLocation = owner.getEntryLocation();</span>
        }
<span class="nc" id="L1024">        return entryLocation;</span>
    }

    /**
     * Sets the entry location in which this unit will be put when
     * returning from {@link Europe}.
     *
     * @param entryLocation The new entry &lt;code&gt;Location&lt;/code&gt;.
     * @see #getEntryLocation
     */
    public void setEntryLocation(Location entryLocation) {
<span class="fc" id="L1035">        this.entryLocation = entryLocation;</span>
<span class="pc bpc" id="L1036" title="1 of 2 branches missed.">        if (entryLocation != null) {</span>
<span class="fc" id="L1037">            owner.setEntryLocation(entryLocation);</span>
        }
<span class="fc" id="L1039">    }</span>

    /**
     * Gets the entry tile for this unit, or if null the default
     * entry location for the owning player.
     *
     * @return The entry &lt;code&gt;Tile&lt;/code&gt;.
     */
    public Tile getFullEntryLocation() {
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">        return (entryLocation != null) ? (Tile) entryLocation</span>
<span class="pc bpc" id="L1049" title="1 of 2 branches missed.">            : (owner.getEntryLocation() == null) ? null</span>
<span class="nc" id="L1050">            : owner.getEntryLocation().getTile();</span>
    }

    /**
     * Get the moves left this turn.
     *
     * @return The number of moves this &lt;code&gt;Unit&lt;/code&gt; has left.
     */
    @Override
    public int getMovesLeft() {
<span class="fc" id="L1060">        return movesLeft;</span>
    }

    /**
     * Sets the moves left this turn.
     *
     * @param moves The new amount of moves left this &lt;code&gt;Unit&lt;/code&gt;
     *     should have.
     */
    public void setMovesLeft(int moves) {
<span class="fc bfc" id="L1070" title="All 2 branches covered.">        this.movesLeft = (moves &lt; 0) ? 0 : moves;</span>
<span class="fc" id="L1071">    }</span>

    /**
     * Gets the type of goods this unit is producing in its current occupation.
     *
     * @return The type of goods this unit is producing.
     */
    public GoodsType getWorkType() {
<span class="fc" id="L1079">        return workType;</span>
    }

    /**
     * Set the type of goods this unit is producing in its current
     * occupation.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void setWorkType(GoodsType type) {
<span class="fc" id="L1089">        this.workType = type;</span>
<span class="fc" id="L1090">    }</span>

    /**
     * Change the type of goods this unit is producing in its current
     * occupation.  Updates the work location production and the unit
     * experience type if necessary.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to produce.
     */
    public void changeWorkType(GoodsType type) {
<span class="fc" id="L1100">        setWorkType(type);</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">        if (type != null) experienceType = type;</span>
<span class="fc" id="L1102">        WorkLocation wl = getWorkLocation();</span>
<span class="fc bfc" id="L1103" title="All 2 branches covered.">        if (wl != null) wl.updateProductionType();</span>
<span class="fc" id="L1104">    }</span>

    /**
     * Gets the type of goods this unit has accrued experience producing.
     *
     * @return The type of goods this unit would produce.
     */
    public GoodsType getExperienceType() {
<span class="fc" id="L1112">        return experienceType;</span>
    }

    /**
     * Gets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @return The experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     *     experienceType.
     * @see #modifyExperience
     */
    public int getExperience() {
<span class="fc" id="L1124">        return experience;</span>
    }

    /**
     * Sets the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param experience The new experience of this &lt;code&gt;Unit&lt;/code&gt;
     *     at its current experienceType.
     * @see #modifyExperience
     */
    public void setExperience(int experience) {
<span class="fc" id="L1136">        this.experience = Math.min(experience,</span>
<span class="fc" id="L1137">                                   getType().getMaximumExperience());</span>
<span class="fc" id="L1138">    }</span>

    /**
     * Modifies the experience of this &lt;code&gt;Unit&lt;/code&gt; at its current
     * experienceType.
     *
     * @param value The value by which to modify the experience of this
     *     &lt;code&gt;Unit&lt;/code&gt;.
     * @see #getExperience
     */
    public void modifyExperience(int value) {
<span class="fc" id="L1149">        experience += value;</span>
<span class="fc" id="L1150">    }</span>

    /**
     * Gets the amount of work left.
     *
     * @return The amount of work left.
     */
    public int getWorkLeft() {
<span class="fc" id="L1158">        return workLeft;</span>
    }

    /**
     * Sets the amount of work left.
     *
     * @param workLeft The new amount of work left.
     */
    public void setWorkLeft(int workLeft) {
<span class="fc" id="L1167">        this.workLeft = workLeft;</span>
<span class="fc" id="L1168">    }</span>

    /**
     * Get the number of turns of work left.
     *
     * @return The number of turns of work left.
     */
    public int getWorkTurnsLeft() {
<span class="pc bpc" id="L1176" title="1 of 2 branches missed.">        return (state == UnitState.IMPROVING</span>
<span class="fc bfc" id="L1177" title="All 2 branches covered.">                &amp;&amp; unitType.hasAbility(Ability.EXPERT_PIONEER))</span>
<span class="fc" id="L1178">            ? (getWorkLeft() + 1) / 2</span>
<span class="fc" id="L1179">            : getWorkLeft();</span>
    }

    /**
     * Gets the TileImprovement that this pioneer is contributing to.
     *
     * @return The &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is working on.
     */
    public TileImprovement getWorkImprovement() {
<span class="fc" id="L1188">        return workImprovement;</span>
    }

    /**
     * Sets the TileImprovement that this pioneer is contributing to.
     *
     * @param imp The new &lt;code&gt;TileImprovement&lt;/code&gt; the pioneer is to
     *     work on.
     */
    public void setWorkImprovement(TileImprovement imp) {
<span class="fc" id="L1198">        workImprovement = imp;</span>
<span class="fc" id="L1199">    }</span>

    /**
     * Get the unit being taught.
     *
     * @return A student &lt;code&gt;Unit&lt;/code&gt; if any.
     */
    public final Unit getStudent() {
<span class="fc" id="L1207">        return student;</span>
    }

    /**
     * Set the student unit.
     *
     * @param newStudent The new student &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setStudent(final Unit newStudent) {
<span class="fc" id="L1216">        Unit oldStudent = this.student;</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">        if (oldStudent == newStudent) return;</span>

<span class="fc bfc" id="L1219" title="All 2 branches covered.">        if (newStudent == null) {</span>
<span class="fc" id="L1220">            this.student = null;</span>
<span class="pc bpc" id="L1221" title="1 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="fc" id="L1222">                oldStudent.setTeacher(null);</span>
            }
<span class="pc bpc" id="L1224" title="1 of 2 branches missed.">        } else if (newStudent.getColony() != null</span>
<span class="pc bpc" id="L1225" title="1 of 2 branches missed.">            &amp;&amp; newStudent.getColony() == getColony()</span>
<span class="pc bpc" id="L1226" title="1 of 2 branches missed.">            &amp;&amp; newStudent.canBeStudent(this)) {</span>
<span class="pc bpc" id="L1227" title="3 of 4 branches missed.">            if (oldStudent != null &amp;&amp; oldStudent.getTeacher() == this) {</span>
<span class="nc" id="L1228">                oldStudent.setTeacher(null);</span>
            }
<span class="fc" id="L1230">            this.student = newStudent;</span>
<span class="fc" id="L1231">            newStudent.setTeacher(this);</span>
<span class="fc" id="L1232">        } else {</span>
<span class="nc" id="L1233">            throw new IllegalStateException(&quot;Unit can not be student: &quot;</span>
<span class="nc" id="L1234">                + newStudent);</span>
        }
<span class="fc" id="L1236">    }</span>

    /**
     * Get the unit teaching this one.
     *
     * @return A teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final Unit getTeacher() {
<span class="fc" id="L1244">        return teacher;</span>
    }

    /**
     * Set the teacher for this unit.
     *
     * @param newTeacher The new teacher &lt;code&gt;Unit&lt;/code&gt;.
     */
    public final void setTeacher(final Unit newTeacher) {
<span class="fc" id="L1253">        Unit oldTeacher = this.teacher;</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">        if (newTeacher == oldTeacher) return;</span>

<span class="fc bfc" id="L1256" title="All 2 branches covered.">        if (newTeacher == null) {</span>
<span class="fc" id="L1257">            this.teacher = null;</span>
<span class="pc bpc" id="L1258" title="1 of 4 branches missed.">            if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1259">                oldTeacher.setStudent(null);</span>
            }
<span class="fc" id="L1261">        } else {</span>
<span class="fc" id="L1262">            UnitType skillTaught = newTeacher.getType().getSkillTaught();</span>
<span class="pc bpc" id="L1263" title="1 of 2 branches missed.">            if (newTeacher.getColony() != null</span>
<span class="pc bpc" id="L1264" title="1 of 2 branches missed.">                &amp;&amp; newTeacher.getColony() == getColony()</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">                &amp;&amp; getColony().canTrain(skillTaught)) {</span>
<span class="pc bpc" id="L1266" title="1 of 4 branches missed.">                if (oldTeacher != null &amp;&amp; oldTeacher.getStudent() == this) {</span>
<span class="fc" id="L1267">                    oldTeacher.setStudent(null);</span>
                }
<span class="fc" id="L1269">                this.teacher = newTeacher;</span>
<span class="fc" id="L1270">                this.teacher.setStudent(this);</span>
<span class="fc" id="L1271">            } else {</span>
<span class="nc" id="L1272">                throw new IllegalStateException(&quot;Unit can not be teacher: &quot;</span>
<span class="nc" id="L1273">                    + newTeacher);</span>
            }
        }
<span class="fc" id="L1276">    }</span>

    /**
     * Gets the number of turns this unit has been training.
     *
     * @return The number of turns of training this &lt;code&gt;Unit&lt;/code&gt; has
     *     given.
     * @see #setTurnsOfTraining
     * @see #getNeededTurnsOfTraining
     */
    public int getTurnsOfTraining() {
<span class="fc" id="L1287">        return turnsOfTraining;</span>
    }

    /**
     * Sets the number of turns this unit has been training.
     *
     * @param turnsOfTraining The number of turns of training this
     *     &lt;code&gt;Unit&lt;/code&gt; has given.
     * @see #getNeededTurnsOfTraining
     */
    public void setTurnsOfTraining(int turnsOfTraining) {
<span class="fc" id="L1298">        this.turnsOfTraining = turnsOfTraining;</span>
<span class="fc" id="L1299">    }</span>

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining() {
        // number of turns is 4/6/8 for skill 1/2/3
<span class="fc" id="L1312">        int result = 0;</span>
<span class="pc bpc" id="L1313" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="fc" id="L1314">            result = getNeededTurnsOfTraining(unitType, student.unitType);</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">            if (getColony() != null) {</span>
<span class="fc" id="L1316">                result -= getColony().getProductionBonus();</span>
            }
        }
<span class="fc" id="L1319">        return result;</span>
    }

    /**
     * Gets the number of turns this unit has to train to educate a student.
     * This value is only meaningful for units that can be put in a school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent the student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The turns of training needed to teach its current type
     *     to a free colonist or to promote an indentured servant or a
     *     petty criminal.
     * @see #getTurnsOfTraining
     */
    public int getNeededTurnsOfTraining(UnitType typeTeacher,
                                        UnitType typeStudent) {
<span class="fc" id="L1335">        UnitType teaching = getUnitTypeTeaching(typeTeacher, typeStudent);</span>
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">        if (teaching != null) {</span>
<span class="fc" id="L1337">            return typeStudent.getEducationTurns(teaching);</span>
        } else {
<span class="nc" id="L1339">            throw new IllegalStateException(&quot;typeTeacher=&quot; + typeTeacher</span>
<span class="nc" id="L1340">                + &quot; typeStudent=&quot; + typeStudent);</span>
        }
    }

    /**
     * Gets the UnitType which a teacher is teaching to a student.
     * This value is only meaningful for teachers that can be put in a
     * school.
     *
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @return The &lt;code&gt;UnitType&lt;/code&gt; taught.
     * @see #getTurnsOfTraining
     *
     */
    public static UnitType getUnitTypeTeaching(UnitType typeTeacher,
                                               UnitType typeStudent) {
<span class="fc" id="L1357">        UnitType skillTaught = typeTeacher.getSkillTaught();</span>
<span class="fc bfc" id="L1358" title="All 2 branches covered.">        if (typeStudent.canBeUpgraded(skillTaught, ChangeType.EDUCATION)) {</span>
<span class="fc" id="L1359">            return skillTaught;</span>
        } else {
<span class="fc" id="L1361">            return typeStudent.getEducationUnit(0);</span>
        }
    }

    /**
     * Can this unit be a student?
     *
     * @param teacher The teacher &lt;code&gt;Unit&lt;/code&gt; which is trying to
     *     teach it.
     * @return True if the unit can be taught by the teacher.
     */
    public boolean canBeStudent(Unit teacher) {
<span class="fc bfc" id="L1373" title="All 4 branches covered.">        return teacher != this &amp;&amp; canBeStudent(unitType, teacher.unitType);</span>
    }

    /**
     * Can a unit be a student?
     *
     * @param typeStudent The student &lt;code&gt;UnitType&lt;/code&gt;.
     * @param typeTeacher The teacher &lt;code&gt;UnitType&lt;/code&gt;.
     * @return True if the student can be taught by the teacher.
     */
    public boolean canBeStudent(UnitType typeStudent, UnitType typeTeacher) {
<span class="fc bfc" id="L1384" title="All 2 branches covered.">        return getUnitTypeTeaching(typeTeacher, typeStudent) != null;</span>
    }

    /**
     * Gets the nationality of this Unit.
     *
     * Nationality represents a Unit's personal allegiance to a
     * nation.  This may conflict with who currently issues orders to
     * the Unit (the owner).
     *
     * @return The nationality of this Unit.
     */
    public String getNationality() {
<span class="nc" id="L1397">        return nationality;</span>
    }

    /**
     * Sets the nationality of this Unit.  A unit will change
     * nationality when it switches owners willingly.  Currently only
     * Converts do this, but it opens the possibility of
     * naturalisation.
     *
     * @param newNationality The new nationality of this Unit.
     */
    public void setNationality(String newNationality) {
<span class="nc bnc" id="L1409" title="All 2 branches missed.">        if (isPerson()) {</span>
<span class="nc" id="L1410">            nationality = newNationality;</span>
<span class="nc" id="L1411">        } else {</span>
<span class="nc" id="L1412">            throw new UnsupportedOperationException(&quot;Can not set the nationality of a Unit which is not a person!&quot;);</span>
        }
<span class="nc" id="L1414">    }</span>

    /**
     * Gets the ethnicity of this Unit.
     *
     * Ethnicity is inherited from the inhabitants of the place where
     * the Unit was born.  Allows former converts to become
     * native-looking colonists.
     *
     * @return The ethnicity of this Unit.
     */
    public String getEthnicity() {
<span class="nc" id="L1426">        return ethnicity;</span>
    }

    /**
     * Sets the ethnicity of this Unit.
     *
     * @param newEthnicity The new ethnicity of this Unit.
     */
    public void setEthnicity(String newEthnicity) {
<span class="nc" id="L1435">        this.ethnicity = newEthnicity;</span>
<span class="nc" id="L1436">    }</span>

    /**
     * Identifies whether this unit came from a native tribe.
     *
     * @return Whether this unit looks native or not.
     */
    public boolean hasNativeEthnicity() {
        try {
            // FIXME: getNation() could fail, but getNationType()
            // doesn't work as expected
<span class="nc" id="L1447">            return getGame().getSpecification().getNation(ethnicity)</span>
<span class="nc" id="L1448">                .getType().isIndian();</span>
<span class="nc" id="L1449">        } catch (Exception e) {</span>
<span class="nc" id="L1450">            return false;</span>
        }
    }

    /**
     * Gets the &lt;code&gt;IndianSettlement&lt;/code&gt; home for this unit.
     *
     * @return The home &lt;code&gt;IndianSettlement&lt;/code&gt; of this unit.
     */
    public IndianSettlement getHomeIndianSettlement() {
<span class="fc" id="L1460">        return indianSettlement;</span>
    }

    /**
     * Sets the home &lt;code&gt;IndianSettlement&lt;/code&gt; for this unit.
     *
     * @param indianSettlement The &lt;code&gt;IndianSettlement&lt;/code&gt; that should
     *     now own this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public void setHomeIndianSettlement(IndianSettlement indianSettlement) {
<span class="fc bfc" id="L1470" title="All 2 branches covered.">        if (this.indianSettlement != null) {</span>
<span class="fc" id="L1471">            this.indianSettlement.removeOwnedUnit(this);</span>
        }

<span class="fc" id="L1474">        this.indianSettlement = indianSettlement;</span>

<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if (indianSettlement != null) {</span>
<span class="fc" id="L1477">            indianSettlement.addOwnedUnit(this);</span>
        }
<span class="fc" id="L1479">    }</span>

    /**
     * Gets the unit hit points.
     *
     * This is currently only used for damaged ships, but might get an
     * extended use later.
     *
     * @return The hit points this &lt;code&gt;Unit&lt;/code&gt; has.
     * @see UnitType#getHitPoints
     */
    public int getHitPoints() {
<span class="fc" id="L1491">        return hitPoints;</span>
    }

    /**
     * Sets the hit points for this unit.
     *
     * @param hitPoints The new hit points for this unit.
     */
    public void setHitPoints(int hitPoints) {
<span class="fc" id="L1500">        this.hitPoints = hitPoints;</span>
<span class="fc" id="L1501">    }</span>

    /**
     * Checks if this unit is under repair.
     *
     * @return True if under repair.
     */
    public boolean isDamaged() {
<span class="fc bfc" id="L1509" title="All 2 branches covered.">        return hitPoints &lt; unitType.getHitPoints();</span>
    }

    /**
     * Get how many turns left to be repaired
     *
     * @return The number of turns left to be repaired.
     */
    public int getTurnsForRepair() {
<span class="fc" id="L1518">        return unitType.getHitPoints() - getHitPoints();</span>
    }

    /**
     * Get the destination of this unit.
     *
     * @return The destination &lt;code&gt;Location&lt;/code&gt; of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public Location getDestination() {
<span class="fc" id="L1527">        return destination;</span>
    }

    /**
     * Sets the destination of this unit.
     *
     * @param newDestination The new destination &lt;code&gt;Location&lt;/code&gt;.
     */
    public void setDestination(Location newDestination) {
<span class="fc" id="L1536">        this.destination = newDestination;</span>
<span class="fc" id="L1537">    }</span>

    /**
     * Get the unit trade route, if any.
     *
     * @return The &lt;code&gt;TradeRoute&lt;/code&gt;, or null if none.
     */
    public final TradeRoute getTradeRoute() {
<span class="fc" id="L1545">        return tradeRoute;</span>
    }

    /**
     * Set the unit trade route.
     *
     * @param newTradeRoute The new &lt;code&gt;TradeRoute&lt;/code&gt; value.
     */
    public final void setTradeRoute(final TradeRoute newTradeRoute) {
<span class="fc" id="L1554">        this.tradeRoute = newTradeRoute;</span>
<span class="fc" id="L1555">    }</span>

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public TradeRouteStop getStop() {
<span class="nc bnc" id="L1563" title="All 2 branches missed.">        return (validateCurrentStop() &lt; 0) ? null</span>
<span class="nc" id="L1564">            : getTradeRoute().getStops().get(currentStop);</span>
    }

    /**
     * Get the stop the unit is heading for or at.
     *
     * @return The target &lt;code&gt;Stop&lt;/code&gt;.
     */
    public List&lt;TradeRouteStop&gt; getCurrentStops() {
<span class="nc bnc" id="L1573" title="All 2 branches missed.">        if (validateCurrentStop() &lt; 0) return null;</span>
<span class="nc" id="L1574">        List&lt;TradeRouteStop&gt; stops</span>
<span class="nc" id="L1575">            = new ArrayList&lt;TradeRouteStop&gt;(getTradeRoute().getStops());</span>
<span class="nc" id="L1576">        rotate(stops, currentStop);</span>
<span class="nc" id="L1577">        return stops;</span>
    }

    /**
     * Get the current trade route stop.
     *
     * @return The current stop index.
     */
    public int getCurrentStop() {
<span class="nc" id="L1586">        return currentStop;</span>
    }

    /**
     * Set the current stop.
     *
     * @param currentStop A new value for the currentStop.
     */
    public void setCurrentStop(int currentStop) {
<span class="nc" id="L1595">        this.currentStop = currentStop;</span>
<span class="nc" id="L1596">    }</span>

    /**
     * Validate and return the current stop.
     *
     * @return The current stop index, or negative on failure.
     */
    public int validateCurrentStop() {
<span class="nc bnc" id="L1604" title="All 2 branches missed.">        if (tradeRoute == null) {</span>
<span class="nc" id="L1605">            currentStop = -1;</span>
<span class="nc" id="L1606">        } else {</span>
<span class="nc" id="L1607">            List&lt;TradeRouteStop&gt; stops = tradeRoute.getStops();</span>
<span class="nc bnc" id="L1608" title="All 4 branches missed.">            if (stops == null || stops.isEmpty()) {</span>
<span class="nc" id="L1609">                currentStop = -1;</span>
<span class="nc" id="L1610">            } else {</span>
<span class="nc bnc" id="L1611" title="All 4 branches missed.">                if (currentStop &lt; 0 || currentStop &gt;= stops.size()) {</span>
                    // The current stop can become out of range if the trade
                    // route is modified.
<span class="nc" id="L1614">                    currentStop = 0;</span>
                }
            }
        }
<span class="nc" id="L1618">        return currentStop;</span>
    }

    /**
     * Convenience function to check if a unit is at a stop.
     *
     * @param stop The &lt;code&gt;TradeRouteStop&lt;/code&gt; to check.
     * @return True if the unit is at the given stop.
     */
    public boolean atStop(TradeRouteStop stop) {
<span class="nc" id="L1628">        return Map.isSameLocation(getLocation(), stop.getLocation());</span>
    }

    /**
     * Get the current trade location.
     *
     * @return The &lt;code&gt;TradeLocation&lt;/code&gt; for this unit.
     */
    public TradeLocation getTradeLocation() {
        Colony colony;
        IndianSettlement is;
<span class="nc bnc" id="L1639" title="All 2 branches missed.">        return ((colony = getColony()) != null) ? colony</span>
<span class="nc bnc" id="L1640" title="All 2 branches missed.">            : ((is = getIndianSettlement()) != null) ? is</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">            : (isInEurope()) ? (TradeLocation)getOwner().getEurope()</span>
<span class="nc" id="L1642">            : null;</span>
    }

    /**
     * Get the current amount of treasure in this unit.
     *
     * @return The amount of treasure.
     * @exception IllegalStateException if this is not a treasure
     *     carrying unit.
     */
    public int getTreasureAmount() {
<span class="pc bpc" id="L1653" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1654">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1656">        return treasureAmount;</span>
    }

    /**
     * Set the amount of treasure in this unit.
     *
     * @param amount The new amount of treasure.
     */
    public void setTreasureAmount(int amount) {
<span class="pc bpc" id="L1665" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L1666">            throw new IllegalStateException(&quot;Unit can not carry treasure&quot;);</span>
        }
<span class="fc" id="L1668">        this.treasureAmount = amount;</span>
<span class="fc" id="L1669">    }</span>

    /**
     * Gets the attrition of this unit.
     *
     * @return The attrition of this unit.
     */
    public int getAttrition() {
<span class="fc" id="L1677">        return attrition;</span>
    }

    /**
     * Sets the attrition of this unit.
     *
     * @param attrition The new attrition of this unit.
     */
    public void setAttrition(int attrition) {
<span class="fc" id="L1686">        this.attrition = attrition;</span>
<span class="fc" id="L1687">    }</span>

    /**
     * Get the visible amount of goods that is carried by this unit.
     *
     * @return The visible amount of goods carried by this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getVisibleGoodsCount() {
<span class="pc bpc" id="L1695" title="1 of 2 branches missed.">        return (visibleGoodsCount &gt;= 0) ? visibleGoodsCount</span>
<span class="fc" id="L1696">            : getGoodsSpaceTaken();</span>
    }


    // Combat routines

    /**
     * Gets a role that can be equipped automatically assumed
     * in case of an attack.
     *
     * Paul Revere makes an unarmed colonist in a settlement pick up a
     * stock-piled musket if attacked, so the bonus should be applied
     * for unarmed colonists inside colonies where there are muskets
     * available.  Natives can also auto-arm.
     *
     * @return A &lt;code&gt;Role&lt;/code&gt; that can be automatically assumed
     *     by this unit, or null if none.
     */
    public Role getAutomaticRole() {
<span class="fc bfc" id="L1715" title="All 2 branches covered.">        if (!hasDefaultRole()) return null;</span>
<span class="fc" id="L1716">        Set&lt;Ability&gt; autoDefence = getAbilities(Ability.AUTOMATIC_EQUIPMENT);</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">        if (autoDefence.isEmpty()) return null;</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        Settlement settlement = (isInColony()) ? getColony()</span>
<span class="fc bfc" id="L1719" title="All 2 branches covered.">            : (getLocation() instanceof IndianSettlement)</span>
<span class="fc" id="L1720">            ? (Settlement)getLocation()</span>
<span class="fc" id="L1721">            : null;</span>
<span class="fc bfc" id="L1722" title="All 2 branches covered.">        if (settlement == null) return null;</span>

<span class="fc" id="L1724">        final Specification spec = getSpecification();</span>
<span class="fc bfc" id="L1725" title="All 2 branches covered.">        for (Ability ability : autoDefence) {</span>
<span class="fc bfc" id="L1726" title="All 2 branches covered.">            for (Scope scope : ability.getScopes()) {</span>
<span class="fc" id="L1727">                Role role = spec.getRole(scope.getType());</span>
<span class="pc bpc" id="L1728" title="1 of 2 branches missed.">                if (role != null</span>
<span class="fc bfc" id="L1729" title="All 2 branches covered.">                    &amp;&amp; settlement.containsGoods(getGoodsDifference(role, 1))) {</span>
<span class="fc" id="L1730">                    return role;</span>
                }
            }
        }
<span class="fc" id="L1734">        return null;</span>
    }

    /**
     * After winning a battle, can this unit capture the loser's role
     * equipment?
     *
     * @param role The loser unit &lt;code&gt;Role&lt;/code&gt;.
     * @return The &lt;code&gt;Role&lt;/code&gt; available to this unit as a result
     *     of capturing the loser equipment.
     */
    public Role canCaptureEquipment(Role role) {
<span class="fc bfc" id="L1746" title="All 2 branches covered.">        if (!hasAbility(Ability.CAPTURE_EQUIPMENT)) return null;</span>
<span class="fc" id="L1747">        final Specification spec = getSpecification();</span>
<span class="fc" id="L1748">        final Role oldRole = getRole();</span>
<span class="fc bfc" id="L1749" title="All 2 branches covered.">        for (Role r : getAvailableRoles(spec.getMilitaryRoles())) {</span>
<span class="fc bfc" id="L1750" title="All 2 branches covered.">            for (Role.RoleChange rc : r.getRoleChanges()) {</span>
<span class="fc bfc" id="L1751" title="All 2 branches covered.">                if (rc.getFrom(spec) == oldRole</span>
<span class="fc bfc" id="L1752" title="All 2 branches covered.">                    &amp;&amp; rc.getCapture(spec) == role) return r;</span>
            }
        }
<span class="fc" id="L1755">        return null;</span>
    }

    /**
     * Does losing a piece of equipment mean the death of this unit?
     *
     * @return True if the unit is doomed.
     */
    public boolean losingEquipmentKillsUnit() {
<span class="pc bfc" id="L1764" title="All 2 branches covered.">        return hasAbility(Ability.DISPOSE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="pc bpc" id="L1765" title="1 of 2 branches missed.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does losing equipment mean the demotion of this unit?
     *
     * @return True if the unit is to be demoted.
     */
    public boolean losingEquipmentDemotesUnit() {
<span class="fc bfc" id="L1774" title="All 2 branches covered.">        return hasAbility(Ability.DEMOTE_ON_ALL_EQUIPMENT_LOST)</span>
<span class="fc bfc" id="L1775" title="All 2 branches covered.">            &amp;&amp; getRole().getDowngrade() == null;</span>
    }

    /**
     * Does the unit have arms?
     *
     * @return True if the unit has arms.
     */
    public boolean isArmed() {
<span class="fc" id="L1784">        return hasAbility(Ability.ARMED);</span>
    }

    /**
     * Does the unit have a mount?
     *
     * @return True if the unit have a mount.
     */
    public boolean isMounted() {
<span class="fc" id="L1793">        return hasAbility(Ability.MOUNTED);</span>
    }

    /**
     * Is the unit a beached ship?
     *
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached() {
<span class="fc" id="L1802">        return isBeached(getTile());</span>
    }

    /**
     * Would this unit be beached if it was on a particular tile?
     *
     * @param tile The &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if the unit is a beached ship.
     */
    public boolean isBeached(Tile tile) {
<span class="pc bpc" id="L1812" title="1 of 6 branches missed.">        return isNaval() &amp;&amp; tile != null &amp;&amp; tile.isLand()</span>
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">            &amp;&amp; !tile.hasSettlement();</span>
    }

    /**
     * Checks if this is an defensive unit. That is: a unit which can
     * be used to defend a &lt;code&gt;Settlement&lt;/code&gt;.
     *
     * Note! As this method is used by the AI it really means that the
     * unit can defend as is. To be specific an unarmed colonist is
     * not defensive yet, even if Paul Revere and stockpiled muskets
     * are available. That check is only performed on an actual
     * attack.
     *
     * A settlement is lost when there are no more defensive units.
     *
     * @return True if this is a defensive unit meaning it can be used
     *     to defend a &lt;code&gt;Colony&lt;/code&gt;.  This would normally mean
     *     that a defensive unit also will be offensive.
     */
    public boolean isDefensiveUnit() {
<span class="pc bpc" id="L1833" title="1 of 4 branches missed.">        return (unitType.isDefensive() || getRole().isDefensive())</span>
<span class="pc bpc" id="L1834" title="1 of 2 branches missed.">            &amp;&amp; !isCarrier(); // Not wagons or ships</span>
    }

    /**
     * Checks if this is an offensive unit.  That is, one that can
     * attack other units.
     *
     * @return True if this is an offensive unit.
     */
    public boolean isOffensiveUnit() {
<span class="fc bfc" id="L1844" title="All 4 branches covered.">        return unitType.isOffensive() || getRole().isOffensive();</span>
    }

    /**
     * Is an alternate unit a better defender than the current choice.
     * Prefer if there is no current defender, or if the alternate
     * unit is better armed, or provides greater defensive power and
     * does not replace a defensive unit defender with a non-defensive
     * unit.
     *
     * @param defender The current defender &lt;code&gt;Unit&lt;/code&gt;.
     * @param defenderPower Its defence power.
     * @param other An alternate &lt;code&gt;Unit&lt;/code&gt;.
     * @param otherPower Its defence power.
     * @return True if the other unit should be preferred.
     */
    public static boolean betterDefender(Unit defender, double defenderPower,
                                         Unit other, double otherPower) {
<span class="fc bfc" id="L1862" title="All 2 branches covered.">        if (defender == null) {</span>
<span class="fc" id="L1863">            return true;</span>
<span class="pc bpc" id="L1864" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1865" title="1 of 4 branches missed.">            &amp;&amp; !defender.isArmed() &amp;&amp; other.isArmed()) {</span>
<span class="nc" id="L1866">            return true;</span>
<span class="pc bpc" id="L1867" title="2 of 4 branches missed.">        } else if (defender.isPerson() &amp;&amp; other.isPerson()</span>
<span class="pc bpc" id="L1868" title="1 of 4 branches missed.">            &amp;&amp; defender.isArmed() &amp;&amp; !other.isArmed()) {</span>
<span class="nc" id="L1869">            return false;</span>
<span class="pc bpc" id="L1870" title="1 of 4 branches missed.">        } else if (!defender.isDefensiveUnit() &amp;&amp; other.isDefensiveUnit()) {</span>
<span class="nc" id="L1871">            return true;</span>
<span class="pc bpc" id="L1872" title="1 of 4 branches missed.">        } else if (defender.isDefensiveUnit() &amp;&amp; !other.isDefensiveUnit()) {</span>
<span class="nc" id="L1873">            return false;</span>
        } else {
<span class="pc bpc" id="L1875" title="1 of 2 branches missed.">            return defenderPower &lt; otherPower;</span>
        }
    }

    /**
     * Finds the closest &lt;code&gt;Location&lt;/code&gt; to this tile where
     * this ship can be repaired, excluding the current colony.
     *
     * @return The closest &lt;code&gt;Location&lt;/code&gt; where a ship can be
     *     repaired.
     */
    public Location getRepairLocation() {
<span class="fc" id="L1887">        final Player player = getOwner();</span>
<span class="fc" id="L1888">        final Colony notHere = getTile().getColony();</span>
<span class="fc" id="L1889">        Location best = getClosestColony(player.getColonies().stream()</span>
<span class="pc bpc" id="L1890" title="3 of 4 branches missed.">            .filter(c -&gt; c != notHere &amp;&amp; c.hasAbility(Ability.REPAIR_UNITS)));</span>
<span class="pc bpc" id="L1891" title="1 of 2 branches missed.">        return (best != null) ? best : player.getEurope();</span>
    }


    // Movement handling

    /**
     * A move type.
     *
     * @see Unit#getMoveType(Direction)
     */
<span class="fc" id="L1902">    public static enum MoveType {</span>
<span class="fc" id="L1903">        MOVE(null, true),</span>
<span class="fc" id="L1904">        MOVE_HIGH_SEAS(null, true),</span>
<span class="fc" id="L1905">        EXPLORE_LOST_CITY_RUMOUR(null, true),</span>
<span class="fc" id="L1906">        ATTACK_UNIT(null, false),</span>
<span class="fc" id="L1907">        ATTACK_SETTLEMENT(null, false),</span>
<span class="fc" id="L1908">        EMBARK(null, false),</span>
<span class="fc" id="L1909">        ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST(null, false),</span>
<span class="fc" id="L1910">        ENTER_INDIAN_SETTLEMENT_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1911">        ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY(null, false),</span>
<span class="fc" id="L1912">        ENTER_FOREIGN_COLONY_WITH_SCOUT(null, false),</span>
<span class="fc" id="L1913">        ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS(null, false),</span>
<span class="fc" id="L1914">        MOVE_NO_MOVES(&quot;Attempt to move without moves left&quot;),</span>
<span class="fc" id="L1915">        MOVE_NO_ACCESS_LAND(&quot;Attempt to move a naval unit onto land&quot;),</span>
<span class="fc" id="L1916">        MOVE_NO_ACCESS_BEACHED(&quot;Attempt to move onto foreign beached ship&quot;),</span>
<span class="fc" id="L1917">        MOVE_NO_ACCESS_EMBARK(&quot;Attempt to embark onto absent or foreign carrier&quot;),</span>
<span class="fc" id="L1918">        MOVE_NO_ACCESS_FULL(&quot;Attempt to embark onto full carrier&quot;),</span>
<span class="fc" id="L1919">        MOVE_NO_ACCESS_GOODS(&quot;Attempt to trade without goods&quot;),</span>
<span class="fc" id="L1920">        MOVE_NO_ACCESS_CONTACT(&quot;Attempt to interact with natives before contact&quot;),</span>
<span class="fc" id="L1921">        MOVE_NO_ACCESS_MISSION_BAN(&quot;Attempt to use missionary at banned settlement&quot;),</span>
<span class="fc" id="L1922">        MOVE_NO_ACCESS_SETTLEMENT(&quot;Attempt to move into foreign settlement&quot;),</span>
<span class="fc" id="L1923">        MOVE_NO_ACCESS_SKILL(&quot;Attempt to learn skill with incapable unit&quot;),</span>
<span class="fc" id="L1924">        MOVE_NO_ACCESS_TRADE(&quot;Attempt to trade without authority&quot;),</span>
<span class="fc" id="L1925">        MOVE_NO_ACCESS_WAR(&quot;Attempt to trade while at war&quot;),</span>
<span class="fc" id="L1926">        MOVE_NO_ACCESS_WATER(&quot;Attempt to move into a settlement by water&quot;),</span>
<span class="fc" id="L1927">        MOVE_NO_ATTACK_CIVILIAN(&quot;Attempt to attack with civilian unit&quot;),</span>
<span class="fc" id="L1928">        MOVE_NO_ATTACK_MARINE(&quot;Attempt to attack from on board ship&quot;),</span>
<span class="fc" id="L1929">        MOVE_NO_EUROPE(&quot;Attempt to move to Europe by incapable unit&quot;),</span>
<span class="fc" id="L1930">        MOVE_NO_REPAIR(&quot;Attempt to move a unit that is under repair&quot;),</span>
<span class="fc" id="L1931">        MOVE_NO_TILE(&quot;Attempt to move when not on a tile&quot;),</span>
<span class="fc" id="L1932">        MOVE_ILLEGAL(&quot;Unspecified illegal move&quot;);</span>

        /**
         * The reason why this move type is illegal.
         */
        private final String reason;

        /**
         * Does this move type imply progress towards a destination.
         */
        private final boolean progress;

<span class="fc" id="L1944">        MoveType(String reason) {</span>
<span class="fc" id="L1945">            this.reason = reason;</span>
<span class="fc" id="L1946">            this.progress = false;</span>
<span class="fc" id="L1947">        }</span>

<span class="fc" id="L1949">        MoveType(String reason, boolean progress) {</span>
<span class="fc" id="L1950">            this.reason = reason;</span>
<span class="fc" id="L1951">            this.progress = progress;</span>
<span class="fc" id="L1952">        }</span>

        public boolean isLegal() {
<span class="fc bfc" id="L1955" title="All 2 branches covered.">            return this.reason == null;</span>
        }

        public String whyIllegal() {
<span class="pc bpc" id="L1959" title="1 of 2 branches missed.">            return (reason == null) ? &quot;(none)&quot; : reason;</span>
        }

        public boolean isProgress() {
<span class="fc" id="L1963">            return progress;</span>
        }

        public boolean isAttack() {
<span class="pc bpc" id="L1967" title="2 of 4 branches missed.">            return this == ATTACK_UNIT || this == ATTACK_SETTLEMENT;</span>
        }
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; onto the given
     * &lt;code&gt;Tile&lt;/code&gt;. A call to {@link #getMoveType(Tile)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            onto.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile target) {
<span class="fc" id="L1982">        return getMoveCost(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the cost of moving this &lt;code&gt;Unit&lt;/code&gt; from the given
     * &lt;code&gt;Tile&lt;/code&gt; onto the given &lt;code&gt;Tile&lt;/code&gt;. A call to
     * {@link #getMoveType(Tile, Tile, int)} will return
     * &lt;code&gt;MOVE_NO_MOVES&lt;/code&gt;, if {@link #getMoveCost} returns a move cost
     * larger than the {@link #getMovesLeft moves left}.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            from.
     * @param target The &lt;code&gt;Tile&lt;/code&gt; this &lt;code&gt;Unit&lt;/code&gt; will move
     *            onto.
     * @param ml The amount of moves this Unit has left.
     * @return The cost of moving this unit onto the given &lt;code&gt;Tile&lt;/code&gt;.
     */
    public int getMoveCost(Tile from, Tile target, int ml) {
        // Remember to also change map.findPath(...) if you change anything
        // here.

<span class="fc" id="L2003">        int cost = target.getType().getBasicMoveCost();</span>
<span class="fc bfc" id="L2004" title="All 4 branches covered.">        if (target.isLand() &amp;&amp; !isNaval()) {</span>
<span class="fc" id="L2005">            TileItemContainer container = target.getTileItemContainer();</span>
<span class="fc bfc" id="L2006" title="All 2 branches covered.">            if (container != null) {</span>
<span class="fc" id="L2007">                cost = container.getMoveCost(from, target, cost);</span>
            }
        }

<span class="pc bpc" id="L2011" title="1 of 2 branches missed.">        if (isBeached(from)) {</span>
            // Ship on land due to it was in a colony which was abandoned
<span class="nc" id="L2013">            cost = ml;</span>
<span class="pc bfc" id="L2014" title="All 2 branches covered.">        } else if (cost &gt; ml) {</span>
            // Using +2 in order to make 1/3 and 2/3 move count as
            // 3/3, only when getMovesLeft &gt; 0
<span class="pc bpc" id="L2017" title="1 of 4 branches missed.">            if ((ml + 2 &gt;= getInitialMovesLeft() || cost &lt;= ml + 2</span>
<span class="fc bfc" id="L2018" title="All 4 branches covered.">                 || target.hasSettlement()) &amp;&amp; ml != 0) {</span>
<span class="fc" id="L2019">                cost = ml;</span>
            }
        }
<span class="fc" id="L2022">        return cost;</span>
    }

    /**
     * Gets the type of a move made in a specified direction.
     *
     * @param direction The &lt;code&gt;Direction&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Direction direction) {
        Tile target;
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2034">            ? MoveType.MOVE_NO_TILE</span>
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
<span class="nc" id="L2036">            ? MoveType.MOVE_ILLEGAL</span>
<span class="fc" id="L2037">            : getMoveType(target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    public MoveType getMoveType(Tile target) {
<span class="pc bpc" id="L2048" title="1 of 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2049">            ? MoveType.MOVE_NO_TILE</span>
<span class="fc" id="L2050">            : getMoveType(getTile(), target, getMovesLeft());</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param ml The amount of moves this unit has left.
     * @return The move type.
     */
    public MoveType getMoveType(Tile from, Tile target, int ml) {
<span class="fc" id="L2063">        MoveType move = getSimpleMoveType(from, target);</span>
<span class="fc bfc" id="L2064" title="All 2 branches covered.">        if (move.isLegal()) {</span>
<span class="fc bfc" id="L2065" title="All 2 branches covered.">            switch (move) {</span>
            case ATTACK_UNIT: case ATTACK_SETTLEMENT:
                // Needs only a single movement point, regardless of
                // terrain, but suffers penalty.
<span class="fc bfc" id="L2069" title="All 2 branches covered.">                if (ml &lt;= 0) {</span>
<span class="fc" id="L2070">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
<span class="fc" id="L2072">                break;</span>
            default:
<span class="pc bpc" id="L2074" title="1 of 2 branches missed.">                if (ml &lt;= 0</span>
<span class="pc bpc" id="L2075" title="2 of 4 branches missed.">                    || (from != null &amp;&amp; getMoveCost(from, target, ml) &gt; ml)) {</span>
<span class="nc" id="L2076">                    move = MoveType.MOVE_NO_MOVES;</span>
                }
                break;
            }
        }
<span class="fc" id="L2081">        return move;</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile from, Tile target) {
<span class="fc bfc" id="L2095" title="All 2 branches covered.">        return (isNaval()) ? getNavalMoveType(from, target)</span>
<span class="fc" id="L2096">            : getLandMoveType(from, target);</span>
    }

    /**
     * Gets the type of a move that is made when moving from one tile
     * to another, without checking if the unit has moves left or
     * logging errors.
     *
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type, which will be one of the extended illegal move
     *         types on failure.
     */
    public MoveType getSimpleMoveType(Tile target) {
<span class="nc bnc" id="L2109" title="All 2 branches missed.">        return (!hasTile()) ? MoveType.MOVE_NO_TILE</span>
<span class="nc" id="L2110">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move made in a specified direction,
     * without checking if the unit has moves left or logging errors.
     *
     * @param direction The direction of the move.
     * @return The move type.
     */
    public MoveType getSimpleMoveType(Direction direction) {
        Tile target;
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        return (!hasTile())</span>
<span class="nc" id="L2123">            ? MoveType.MOVE_NO_TILE</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">            : ((target = getTile().getNeighbourOrNull(direction)) == null)</span>
<span class="nc" id="L2125">            ? MoveType.MOVE_ILLEGAL</span>
<span class="nc" id="L2126">            : getSimpleMoveType(getTile(), target);</span>
    }

    /**
     * Gets the type of a move that is made when moving a naval unit
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getNavalMoveType(@SuppressWarnings(&quot;unused&quot;) Tile from,
                                      Tile target) {
<span class="pc bpc" id="L2139" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc bnc" id="L2140" title="All 2 branches missed.">            return (getOwner().canMoveToEurope()) ? MoveType.MOVE_HIGH_SEAS</span>
<span class="nc" id="L2141">                : MoveType.MOVE_NO_EUROPE;</span>
<span class="pc bpc" id="L2142" title="1 of 2 branches missed.">        } else if (isDamaged()) {</span>
<span class="nc" id="L2143">            return MoveType.MOVE_NO_REPAIR;</span>
        }

<span class="fc bfc" id="L2146" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2147">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2148" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc" id="L2149">                return MoveType.MOVE_NO_ACCESS_LAND;</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">            } else if (settlement.getOwner() == getOwner()) {</span>
<span class="fc" id="L2151">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2152" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="fc" id="L2153">                return getTradeMoveType(settlement);</span>
            } else {
<span class="nc" id="L2155">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // target at sea
<span class="fc" id="L2158">            Unit defender = target.getFirstUnit();</span>
<span class="fc bfc" id="L2159" title="All 4 branches covered.">            if (defender != null &amp;&amp; !getOwner().owns(defender)) {</span>
<span class="fc bfc" id="L2160" title="All 2 branches covered.">                return (isOffensiveUnit())</span>
<span class="fc" id="L2161">                    ? MoveType.ATTACK_UNIT</span>
<span class="fc" id="L2162">                    : MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
            } else {
<span class="fc bfc" id="L2164" title="All 2 branches covered.">                return (target.isDirectlyHighSeasConnected())</span>
<span class="fc" id="L2165">                    ? MoveType.MOVE_HIGH_SEAS</span>
<span class="fc" id="L2166">                    : MoveType.MOVE;</span>
            }
        }
    }

    /**
     * Gets the type of a move that is made when moving a land unit to
     * from one tile to another.
     *
     * @param from The origin &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @param target The target &lt;code&gt;Tile&lt;/code&gt; of the move.
     * @return The move type.
     */
    private MoveType getLandMoveType(Tile from, Tile target) {
<span class="pc bpc" id="L2180" title="1 of 2 branches missed.">        if (target == null) return MoveType.MOVE_ILLEGAL;</span>

<span class="fc" id="L2182">        Player owner = getOwner();</span>
<span class="fc" id="L2183">        Unit defender = target.getFirstUnit();</span>

<span class="fc bfc" id="L2185" title="All 2 branches covered.">        if (target.isLand()) {</span>
<span class="fc" id="L2186">            Settlement settlement = target.getSettlement();</span>
<span class="fc bfc" id="L2187" title="All 2 branches covered.">            if (settlement == null) {</span>
<span class="fc bfc" id="L2188" title="All 4 branches covered.">                if (defender != null &amp;&amp; owner != defender.getOwner()) {</span>
<span class="pc bpc" id="L2189" title="1 of 2 branches missed.">                    if (defender.isNaval()) {</span>
<span class="nc" id="L2190">                        return MoveType.ATTACK_UNIT;</span>
<span class="fc bfc" id="L2191" title="All 2 branches covered.">                    } else if (!isOffensiveUnit()) {</span>
<span class="fc" id="L2192">                        return MoveType.MOVE_NO_ATTACK_CIVILIAN;</span>
                    } else {
<span class="pc bpc" id="L2194" title="1 of 2 branches missed.">                        return (allowMoveFrom(from))</span>
<span class="fc" id="L2195">                            ? MoveType.ATTACK_UNIT</span>
<span class="nc" id="L2196">                            : MoveType.MOVE_NO_ATTACK_MARINE;</span>
                    }
<span class="pc bpc" id="L2198" title="1 of 4 branches missed.">                } else if (target.hasLostCityRumour() &amp;&amp; owner.isEuropean()) {</span>
                    // Natives do not explore rumours, see:
                    // server/control/InGameInputHandler.java:move()
<span class="fc" id="L2201">                    return MoveType.EXPLORE_LOST_CITY_RUMOUR;</span>
                } else {
<span class="fc" id="L2203">                    return MoveType.MOVE;</span>
                }
<span class="fc bfc" id="L2205" title="All 2 branches covered.">            } else if (owner == settlement.getOwner()) {</span>
<span class="fc" id="L2206">                return MoveType.MOVE;</span>
<span class="pc bpc" id="L2207" title="1 of 2 branches missed.">            } else if (isTradingUnit()) {</span>
<span class="nc" id="L2208">                return getTradeMoveType(settlement);</span>
<span class="fc bfc" id="L2209" title="All 2 branches covered.">            } else if (isColonist()) {</span>
<span class="fc bfc" id="L2210" title="All 2 branches covered.">                if (settlement instanceof Colony</span>
<span class="fc bfc" id="L2211" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.NEGOTIATE)) {</span>
<span class="pc bpc" id="L2212" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2213">                        ? MoveType.ENTER_FOREIGN_COLONY_WITH_SCOUT</span>
<span class="nc" id="L2214">                        : MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="fc bfc" id="L2215" title="All 2 branches covered.">                } else if (settlement instanceof IndianSettlement</span>
<span class="fc bfc" id="L2216" title="All 2 branches covered.">                    &amp;&amp; hasAbility(Ability.SPEAK_WITH_CHIEF)) {</span>
<span class="pc bpc" id="L2217" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2218">                        ? MoveType.ENTER_INDIAN_SETTLEMENT_WITH_SCOUT</span>
<span class="nc" id="L2219">                        : MoveType.MOVE_NO_ACCESS_WATER;</span>
<span class="fc bfc" id="L2220" title="All 2 branches covered.">                } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2221" title="1 of 2 branches missed.">                    return (allowMoveFrom(from))</span>
<span class="fc" id="L2222">                        ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2223">                        : MoveType.MOVE_NO_ATTACK_MARINE;</span>
<span class="fc bfc" id="L2224" title="All 2 branches covered.">                } else if (hasAbility(Ability.ESTABLISH_MISSION)) {</span>
<span class="fc" id="L2225">                    return getMissionaryMoveType(from, settlement);</span>
                } else {
<span class="fc" id="L2227">                    return getLearnMoveType(from, settlement);</span>
                }
<span class="pc bpc" id="L2229" title="1 of 2 branches missed.">            } else if (isOffensiveUnit()) {</span>
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">                return (allowMoveFrom(from))</span>
<span class="fc" id="L2231">                    ? MoveType.ATTACK_SETTLEMENT</span>
<span class="nc" id="L2232">                    : MoveType.MOVE_NO_ATTACK_MARINE;</span>
            } else {
<span class="nc" id="L2234">                return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
            }
        } else { // moving to sea, check for embarkation
<span class="fc bfc" id="L2237" title="All 4 branches covered.">            return (defender == null || !getOwner().owns(defender))</span>
<span class="fc" id="L2238">                ? MoveType.MOVE_NO_ACCESS_EMBARK</span>
<span class="pc bpc" id="L2239" title="1 of 2 branches missed.">                : (any(target.getUnitList(), u -&gt; u.canAdd(this)))</span>
<span class="fc" id="L2240">                ? MoveType.EMBARK</span>
<span class="nc" id="L2241">                : MoveType.MOVE_NO_ACCESS_FULL;</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a trading unit to a
     * settlement.
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getTradeMoveType(Settlement settlement) {
<span class="pc bpc" id="L2253" title="1 of 2 branches missed.">        if (settlement instanceof Colony) {</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">            return (getOwner().atWarWith(settlement.getOwner()))</span>
<span class="nc" id="L2255">                ? MoveType.MOVE_NO_ACCESS_WAR</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">                : (!hasAbility(Ability.TRADE_WITH_FOREIGN_COLONIES))</span>
<span class="nc" id="L2257">                ? MoveType.MOVE_NO_ACCESS_TRADE</span>
<span class="nc" id="L2258">                : MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS;</span>
<span class="pc bpc" id="L2259" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
            // Do not block for war, bringing gifts is allowed
<span class="fc bfc" id="L2261" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
<span class="fc" id="L2262">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="fc bfc" id="L2263" title="All 2 branches covered.">                : (hasGoodsCargo() || getSpecification()</span>
<span class="fc bfc" id="L2264" title="All 2 branches covered.">                    .getBoolean(GameOptions.EMPTY_TRADERS))</span>
<span class="fc" id="L2265">                ? MoveType.ENTER_SETTLEMENT_WITH_CARRIER_AND_GOODS</span>
<span class="fc" id="L2266">                : MoveType.MOVE_NO_ACCESS_GOODS;</span>
        } else {
<span class="nc" id="L2268">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a colonist to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getLearnMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2280" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2281">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2282" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="fc bfc" id="L2283" title="All 2 branches covered.">            return (!allowContact(settlement))</span>
<span class="fc" id="L2284">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2285" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
<span class="nc" id="L2286">                ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2287" title="1 of 2 branches missed.">                : (!getType().canBeUpgraded(null, ChangeType.NATIVES))</span>
<span class="nc" id="L2288">                ? MoveType.MOVE_NO_ACCESS_SKILL</span>
<span class="fc" id="L2289">                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_FREE_COLONIST;</span>
        } else {
<span class="nc" id="L2291">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Get the &lt;code&gt;MoveType&lt;/code&gt; when moving a missionary to a settlement.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to move from.
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to move to.
     * @return The appropriate &lt;code&gt;MoveType&lt;/code&gt;.
     */
    private MoveType getMissionaryMoveType(Tile from, Settlement settlement) {
<span class="fc bfc" id="L2303" title="All 2 branches covered.">        if (settlement instanceof Colony) {</span>
<span class="fc" id="L2304">            return MoveType.MOVE_NO_ACCESS_SETTLEMENT;</span>
<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">        } else if (settlement instanceof IndianSettlement) {</span>
<span class="pc bpc" id="L2306" title="1 of 2 branches missed.">            return (!allowContact(settlement))</span>
<span class="nc" id="L2307">                ? MoveType.MOVE_NO_ACCESS_CONTACT</span>
<span class="pc bpc" id="L2308" title="1 of 2 branches missed.">                : (!allowMoveFrom(from))</span>
<span class="nc" id="L2309">                ? MoveType.MOVE_NO_ACCESS_WATER</span>
<span class="pc bpc" id="L2310" title="1 of 2 branches missed.">                : (settlement.getOwner().missionsBanned(getOwner()))</span>
<span class="nc" id="L2311">                ? MoveType.MOVE_NO_ACCESS_MISSION_BAN</span>
<span class="fc" id="L2312">                : MoveType.ENTER_INDIAN_SETTLEMENT_WITH_MISSIONARY;</span>
        } else {
<span class="nc" id="L2314">            return MoveType.MOVE_ILLEGAL; // should not happen</span>
        }
    }

    /**
     * Is this unit allowed to move from a source tile?
     * Implements the restrictions on moving from water.
     *
     * @param from The &lt;code&gt;Tile&lt;/code&gt; to consider.
     * @return True if the move is allowed.
     */
    private boolean allowMoveFrom(Tile from) {
<span class="pc bfc" id="L2326" title="All 2 branches covered.">        return from.isLand()</span>
<span class="pc bpc" id="L2327" title="1 of 2 branches missed.">            || (!getOwner().isREF()</span>
<span class="pc bpc" id="L2328" title="1 of 2 branches missed.">                &amp;&amp; getSpecification().getBoolean(GameOptions.AMPHIBIOUS_MOVES));</span>
    }

    /**
     * Is this unit allowed to contact a settlement?
     *
     * @param settlement The &lt;code&gt;Settlement&lt;/code&gt; to consider.
     * @return True if the contact is allowed.
     */
    private boolean allowContact(Settlement settlement) {
<span class="fc" id="L2338">        return getOwner().hasContacted(settlement.getOwner());</span>
    }

    /**
     * Does a basic check whether a unit can ever expect to move to a tile.
     *
     * @param tile The code &lt;code&gt;Tile&lt;/code&gt; to check.
     * @return True if some sort of legal move to the tile exists, including
     *     special cases where there is an interaction but the unit does not
     *     actually move, such as trade.
     */
    public boolean isTileAccessible(Tile tile) {
<span class="fc bfc" id="L2350" title="All 2 branches covered.">        return (isNaval())</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">            ? (!tile.isLand()</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">                || (tile.hasSettlement()</span>
<span class="fc bfc" id="L2353" title="All 2 branches covered.">                    &amp;&amp; getOwner().owns(tile.getSettlement())))</span>
<span class="fc" id="L2354">            : tile.isLand();</span>
    }

    /**
     * Gets the amount of moves this unit has at the beginning of each turn.
     *
     * @return The amount of moves this unit has at the beginning of
     *     each turn.
     */
    @Override
    public int getInitialMovesLeft() {
<span class="fc" id="L2365">        Turn turn = getGame().getTurn();</span>
<span class="fc" id="L2366">        return (int)applyModifiers(unitType.getMovement(), turn,</span>
<span class="fc" id="L2367">                                   Modifier.MOVEMENT_BONUS, unitType);</span>
    }

    /**
     * Make a label showing the unit moves left.
     *
     * @return A movement label.
     */
    public String getMovesAsString() {
<span class="fc" id="L2376">        StringBuilder sb = new StringBuilder(16);</span>
<span class="fc" id="L2377">        int quotient = getMovesLeft() / 3;</span>
<span class="fc" id="L2378">        int remainder = getMovesLeft() % 3;</span>
<span class="fc bfc" id="L2379" title="All 4 branches covered.">        if (quotient &gt; 0 || remainder == 0) sb.append(quotient);</span>
<span class="fc bfc" id="L2380" title="All 2 branches covered.">        if (remainder &gt; 0) {</span>
<span class="fc" id="L2381">            sb.append(&quot;(&quot;).append(remainder).append(&quot;/3) &quot;);</span>
        }
<span class="fc" id="L2383">        sb.append(&quot;/&quot;).append(getInitialMovesLeft() / 3);</span>
<span class="fc" id="L2384">        return sb.toString();</span>
    }

    /**
     * Gets the number of turns this unit will need to sail to/from Europe.
     *
     * @return The number of turns to sail to/from Europe.
     */
    public int getSailTurns() {
<span class="fc" id="L2393">        float base = getSpecification().getInteger(GameOptions.TURNS_TO_SAIL);</span>
<span class="fc" id="L2394">        return (int)getOwner().applyModifiers(base, getGame().getTurn(),</span>
<span class="fc" id="L2395">                                              Modifier.SAIL_HIGH_SEAS,</span>
<span class="fc" id="L2396">                                              unitType);</span>
    }

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; can be moved to the high seas
     * from its current location.
     *
     * @return True if this unit can move immediately to the high seas.
     */
    public boolean canMoveToHighSeas() {
<span class="nc bnc" id="L2406" title="All 4 branches missed.">        if (isInEurope() || isAtSea()) return true;</span>
<span class="nc bnc" id="L2407" title="All 2 branches missed.">        if (!getOwner().canMoveToEurope()</span>
<span class="nc bnc" id="L2408" title="All 2 branches missed.">            || !getType().canMoveToHighSeas()) return false;</span>
<span class="nc" id="L2409">        return getTile().isDirectlyHighSeasConnected();</span>
    }

    /**
     * Does this unit have a valid move to the high seas this turn.
     *
     * @return True if the unit can either move immediately to the high
     *      seas or can make a move to a neighbouring high seas tile.
     */
    public boolean hasHighSeasMove() {
<span class="nc bnc" id="L2419" title="All 2 branches missed.">        return (canMoveToHighSeas())</span>
<span class="nc" id="L2420">            ? true</span>
<span class="nc bnc" id="L2421" title="All 4 branches missed.">            : (hasTile() &amp;&amp; getMovesLeft() &gt; 0)</span>
<span class="nc" id="L2422">            ? any(getTile().getSurroundingTiles(1, 1),</span>
<span class="nc" id="L2423">                Tile::isDirectlyHighSeasConnected)</span>
<span class="nc" id="L2424">            : false;</span>
    }

    /**
     * Check if this unit can build a colony.  Does not consider whether
     * the tile where the unit is located is suitable,
     * @see Player#canClaimToFoundSettlement(Tile)
     *
     * @return &lt;code&gt;true&lt;/code&gt; if this unit can build a colony.
     */
    public boolean canBuildColony() {
<span class="fc" id="L2435">        final Specification spec = getSpecification();</span>
<span class="pc bpc" id="L2436" title="1 of 6 branches missed.">        return hasTile() &amp;&amp; unitType.canBuildColony() &amp;&amp; getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L2437" title="1 of 2 branches missed.">            &amp;&amp; (!getOwner().isRebel()</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">                || spec.getBoolean(GameOptions.FOUND_COLONY_DURING_REBELLION));</span>
    }

    /**
     * Is this unit at a specified location?
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to test.
     * @return True if the locations are the same, or on the same tile.
     */
    public boolean isAtLocation(Location loc) {
<span class="fc" id="L2448">        Location ourLoc = getLocation(),</span>
<span class="fc bfc" id="L2449" title="All 2 branches covered.">            otherLoc = (loc instanceof Unit) ? ((Unit)loc).getLocation() : loc;</span>
<span class="pc bpc" id="L2450" title="1 of 2 branches missed.">        if (ourLoc instanceof Unit) ourLoc = ((Unit)ourLoc).getLocation();</span>
<span class="fc" id="L2451">        return Map.isSameLocation(ourLoc, otherLoc);</span>
    }

    /**
     * Gets the best (closest) entry location for this unit to reach a
     * given tile.
     *
     * @param tile The target &lt;code&gt;Tile&lt;/code&gt;.
     * @return The best entry location tile to arrive on the map at, or null
     *     if none found.
     */
    public Tile getBestEntryTile(Tile tile) {
<span class="nc" id="L2463">        return getGame().getMap().getBestEntryTile(this, tile, null, null);</span>
    }

    /**
     * Resolves a destination for a unit on the high seas.
     * That is, the location where the unit will appear when it leaves
     * the high seas, which will either be Europe or a tile.
     *
     * @return The location the unit should appear next after leaving
     *      the high seas.
     */
    public Location resolveDestination() {
<span class="nc bnc" id="L2475" title="All 2 branches missed.">        if (!isAtSea()) throw new IllegalArgumentException(&quot;Not at sea.&quot;);</span>
<span class="nc" id="L2476">        TradeRouteStop stop = getStop();</span>
<span class="nc bnc" id="L2477" title="All 2 branches missed.">        Location dst = (TradeRoute.isStopValid(this, stop))</span>
<span class="nc" id="L2478">            ? stop.getLocation()</span>
<span class="nc" id="L2479">            : getDestination();</span>
        Tile best;
<span class="nc bnc" id="L2481" title="All 2 branches missed.">        return (dst == null) ? getFullEntryLocation()</span>
<span class="nc bnc" id="L2482" title="All 2 branches missed.">            : (dst instanceof Europe) ? dst</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">            : (dst.getTile() != null</span>
<span class="nc bnc" id="L2484" title="All 2 branches missed.">                &amp;&amp; (best = getBestEntryTile(dst.getTile())) != null) ? best</span>
<span class="nc" id="L2485">            : getFullEntryLocation();</span>
    }

    /**
     * Set movesLeft to 0 if has some spent moves and it's in a colony
     *
     * @see #add(Locatable)
     * @see #remove(Locatable)
     */
    private void spendAllMoves() {
<span class="pc bpc" id="L2495" title="3 of 4 branches missed.">        if (getColony() != null &amp;&amp; getMovesLeft() &lt; getInitialMovesLeft()) {</span>
<span class="nc" id="L2496">            setMovesLeft(0);</span>
        }
<span class="fc" id="L2498">    }</span>

    /**
     * Is this unit a suitable `next active unit', that is, the unit
     * needs to be currently movable by the player.
     *
     * @return True if this unit could still be moved by the player.
     */
    public boolean couldMove() {
<span class="pc bpc" id="L2507" title="1 of 2 branches missed.">        return !isDisposed()</span>
<span class="pc bpc" id="L2508" title="1 of 2 branches missed.">            &amp;&amp; getState() == UnitState.ACTIVE</span>
<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">            &amp;&amp; getMovesLeft() &gt; 0</span>
<span class="pc bpc" id="L2510" title="1 of 2 branches missed.">            &amp;&amp; destination == null // Can not reach next tile</span>
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">            &amp;&amp; tradeRoute == null</span>
<span class="pc bpc" id="L2512" title="1 of 2 branches missed.">            &amp;&amp; !isDamaged()</span>
<span class="pc bpc" id="L2513" title="1 of 2 branches missed.">            &amp;&amp; !isAtSea()</span>
<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">            &amp;&amp; !isOnCarrier()</span>
            // this should never happen anyway, since these units
            // should have state IN_COLONY, but better safe than sorry
<span class="pc bpc" id="L2517" title="1 of 2 branches missed.">            &amp;&amp; !isInColony();</span>
    }


    // Map support routines

    /**
     * Gets a suitable location to start path searches for a unit.
     *
     * Must handle all the cases where the unit is off the map, and
     * take account of the use of a carrier.
     *
     * @return A suitable starting location, or null if none found.
     */
    public Location getPathStartLocation() {
<span class="fc" id="L2532">        final Unit carrier = getCarrier();</span>
<span class="fc" id="L2533">        Location ret = getTile();</span>
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">        if (isOnCarrier()) {</span>
<span class="nc bnc" id="L2535" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2537" title="All 2 branches missed.">            } else if (carrier.getDestination() == null) {</span>
<span class="nc" id="L2538">                ret = null;</span>
<span class="nc bnc" id="L2539" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Map) {</span>
<span class="nc" id="L2540">                ret = carrier.getFullEntryLocation();</span>
<span class="nc bnc" id="L2541" title="All 2 branches missed.">            } else if (carrier.getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2542">                ret = carrier.getDestination();</span>
<span class="nc" id="L2543">            } else { // destination must be Europe</span>
<span class="nc" id="L2544">                ret = null;</span>
            }
<span class="pc bpc" id="L2546" title="1 of 2 branches missed.">        } else if (isNaval()) {</span>
<span class="nc bnc" id="L2547" title="All 2 branches missed.">            if (ret != null) {</span>
                ; // OK
<span class="nc bnc" id="L2549" title="All 2 branches missed.">            } else if (getDestination() == null</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">                || getDestination() instanceof Map) {</span>
<span class="nc" id="L2551">                ret = getFullEntryLocation();</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">            } else if (getDestination() instanceof Settlement) {</span>
<span class="nc" id="L2553">                ret = getDestination();</span>
<span class="nc" id="L2554">            } else {</span>
<span class="nc" id="L2555">                ret = getFullEntryLocation();</span>
            }
        }
<span class="fc bfc" id="L2558" title="All 2 branches covered.">        if (ret != null) return ret;</span>

        // Must be a land unit not on the map.  May have a carrier.
        // Get our nearest settlement to Europe, fallback to any other.
<span class="fc" id="L2562">        final Player owner = getOwner();</span>
<span class="fc" id="L2563">        int bestValue = INFINITY;</span>
<span class="fc bfc" id="L2564" title="All 2 branches covered.">        for (Settlement s : owner.getSettlements()) {</span>
<span class="pc bpc" id="L2565" title="1 of 2 branches missed.">            if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2566">                int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2567" title="All 2 branches missed.">                if (bestValue &gt; value) {</span>
<span class="nc" id="L2568">                    bestValue = value;</span>
<span class="nc" id="L2569">                    ret = s;</span>
                }
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">            } else if (bestValue == INFINITY) ret = s;</span>
        }
<span class="fc bfc" id="L2573" title="All 2 branches covered.">        if (ret != null) return ret;</span>

        // Owner has no settlements.  If it is the REF, start from a
        // rebel colony.  Prefer the closest port.
<span class="pc bpc" id="L2577" title="1 of 2 branches missed.">        if (owner.isREF()) {</span>
<span class="nc" id="L2578">            bestValue = INFINITY;</span>
<span class="nc bnc" id="L2579" title="All 2 branches missed.">            for (Player p : owner.getRebels()) {</span>
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                for (Settlement s : p.getSettlements()) {</span>
<span class="nc bnc" id="L2581" title="All 2 branches missed.">                    if (s.getTile().isHighSeasConnected()) {</span>
<span class="nc" id="L2582">                        int value = s.getTile().getHighSeasCount();</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">                        if (bestValue &gt; value) {</span>
<span class="nc" id="L2584">                            bestValue = value;</span>
<span class="nc" id="L2585">                            ret = s;</span>
                        }
<span class="nc bnc" id="L2587" title="All 2 branches missed.">                    } else if (bestValue == INFINITY) ret = s;</span>
                }
            }
<span class="nc bnc" id="L2590" title="All 2 branches missed.">            if (ret != null) return ret;</span>
        }

        // Desperately find the nearest land to the entry location.
<span class="fc" id="L2594">        Location entry = getFullEntryLocation();</span>
<span class="pc bpc" id="L2595" title="3 of 4 branches missed.">        if (entry != null &amp;&amp; entry.getTile() != null) {</span>
<span class="nc bnc" id="L2596" title="All 2 branches missed.">            for (Tile t : entry.getTile().getSurroundingTiles(INFINITY)) {</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">                if (t.isLand()) return t;</span>
            }
        }

<span class="fc" id="L2601">        return null; // Fail</span>
    }

    /**
     * Should the unit use transport to get to a specified tile?
     *
     * True if:
     * - The location is not null
     * - The unit is not naval
     * - The unit is not there already
     * AND
     *   - there is no path OR the path uses an existing carrier
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt; to go to.
     * @return True if the unit should use transport.
     */
    public boolean shouldTakeTransportTo(Location loc) {
        PathNode path;
<span class="pc bpc" id="L2619" title="1 of 2 branches missed.">        return loc != null</span>
<span class="pc bpc" id="L2620" title="1 of 2 branches missed.">            &amp;&amp; !isNaval()</span>
<span class="fc bfc" id="L2621" title="All 2 branches covered.">            &amp;&amp; !isAtLocation(loc)</span>
<span class="pc bpc" id="L2622" title="1 of 2 branches missed.">            &amp;&amp; ((path = findPath(getLocation(), loc,</span>
<span class="fc" id="L2623">                                 getCarrier(), null)) == null</span>
<span class="pc bpc" id="L2624" title="1 of 2 branches missed.">                || path.usesCarrier());</span>
    }

    /**
     * Gets the trivial path for this unit.  That is, the path to the
     * nearest available safe settlement.
     *
     * @return A path to the trivial target, or null if none found.
     */
    public PathNode getTrivialPath() {
<span class="pc bpc" id="L2634" title="2 of 4 branches missed.">        if (isDisposed() || getLocation() == null) return null;</span>
<span class="fc bfc" id="L2635" title="All 2 branches covered.">        if (!isNaval()) return findOurNearestSettlement();</span>
<span class="fc" id="L2636">        PathNode path = findOurNearestPort();</span>
<span class="fc bfc" id="L2637" title="All 2 branches covered.">        if (path == null) {</span>
            // This is unusual, but can happen when a ship is up a
            // river and foreign ship creates a blockage downstream.
            // If so, the rational thing to do is to go to a tile
            // where other units can pass and which has the best
            // connectivity to the high seas.
<span class="fc" id="L2643">            Tile tile = getTile();</span>
<span class="pc bpc" id="L2644" title="2 of 4 branches missed.">            if (tile != null &amp;&amp; tile.isOnRiver()</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">                &amp;&amp; tile.isHighSeasConnected()) {</span>
<span class="nc" id="L2646">                path = search(getLocation(), </span>
<span class="nc" id="L2647">                    GoalDeciders.getCornerGoalDecider(),</span>
<span class="nc" id="L2648">                    CostDeciders.avoidSettlementsAndBlockingUnits(),</span>
<span class="nc" id="L2649">                    INFINITY, null);</span>
<span class="nc bnc" id="L2650" title="All 4 branches missed.">                if (path == null &amp;&amp; tile.isRiverCorner()) {</span>
                    // Return trivial path if already present.
<span class="nc" id="L2652">                    return new PathNode(tile, 0, 0, false, null, null);</span>
                }
            }
        }
<span class="fc" id="L2656">        return path;</span>
    }

    /**
     * Finds the fastest path from the current location to the
     * specified one.  No carrier is provided, and the default cost
     * decider for this unit is used.
     *
     * @param end The &lt;code&gt;Location&lt;/code&gt; in which the path ends.
     * @return A &lt;code&gt;PathNode&lt;/code&gt; from the current location to the
     *     end location, or null if none found.
     */
    public PathNode findPath(Location end) {
<span class="fc" id="L2669">        return findPath(getLocation(), end, null, null);</span>
    }

    /**
     * Finds a quickest path between specified locations, optionally
     * using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Location&lt;/code&gt; to end at.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPath(Location start, Location end, Unit carrier,
                             CostDecider costDecider) {
<span class="fc" id="L2686">        return getGame().getMap().findPath(this, start, end,</span>
<span class="fc" id="L2687">                                           carrier, costDecider, null);</span>
    }

    /**
     * Finds a quickest path to a neighbouring tile to a specified target
     * tile, optionally using a carrier and special purpose cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start at.
     * @param end The &lt;code&gt;Tile&lt;/code&gt; to end at a neighbour of.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to carry the unit.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; for
     *     determining the movement costs (uses default cost deciders
     *     for the unit/s if not provided).
     * @return A &lt;code&gt;PathNode&lt;/code&gt;, or null if no path is found.
     */
    public PathNode findPathToNeighbour(Location start, Tile end, Unit carrier,
                                        CostDecider costDecider) {
<span class="nc" id="L2704">        final Player owner = getOwner();</span>
<span class="nc" id="L2705">        int bestValue = INFINITY;</span>
<span class="nc" id="L2706">        PathNode best = null;</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">        for (Tile t : end.getSurroundingTiles(1)) {</span>
<span class="nc bnc" id="L2708" title="All 2 branches missed.">            if (isTileAccessible(t)</span>
<span class="nc bnc" id="L2709" title="All 4 branches missed.">                &amp;&amp; (t.getFirstUnit() == null || owner.owns(t.getFirstUnit()))) {</span>
<span class="nc" id="L2710">                PathNode p = findPath(start, t, carrier, costDecider);</span>
<span class="nc bnc" id="L2711" title="All 4 branches missed.">                if (p != null &amp;&amp; bestValue &gt; p.getTotalTurns()) {</span>
<span class="nc" id="L2712">                    bestValue = p.getTotalTurns();</span>
<span class="nc" id="L2713">                    best = p;</span>
                }
            }
        }
<span class="nc" id="L2717">        return best;</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from its current position.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the destination,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location end) {
<span class="fc" id="L2730">        return getTurnsToReach(getLocation(), end);</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location.  If the unit is
     * currently on a carrier, it will be used.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end) {
<span class="fc" id="L2744">        return getTurnsToReach(start, end, getCarrier(),</span>
<span class="fc" id="L2745">            CostDeciders.avoidSettlementsAndBlockingUnits());</span>
    }

    /**
     * Gets the number of turns required for this unit to reach a
     * destination location from a starting location, using an optional
     * carrier and cost decider.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param end The destination &lt;code&gt;Location&lt;/code&gt;.
     * @param carrier An optional carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @param costDecider An optional &lt;code&gt;CostDecider&lt;/code&gt; to
     *     score the path with.
     * @return The number of turns it will take to reach the &lt;code&gt;end&lt;/code&gt;,
     *         or &lt;code&gt;MANY_TURNS&lt;/code&gt; if no path can be found.
     */
    public int getTurnsToReach(Location start, Location end, Unit carrier,
                               CostDecider costDecider) {
<span class="fc" id="L2763">        PathNode path = findPath(start, end, carrier, costDecider);</span>
<span class="pc bpc" id="L2764" title="1 of 2 branches missed.">        return (path == null) ? MANY_TURNS : path.getTotalTurns();</span>
    }

    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A list of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(List&lt;Colony&gt; colonies) {
<span class="nc" id="L2775">        return getClosestColony(colonies.stream());</span>
    }
    
    /**
     * Get the colony that can be reached by this unit in the least number
     * of turns.
     *
     * @param colonies A stream of &lt;code&gt;Colony&lt;/code&gt;s.
     * @return The nearest &lt;code&gt;Colony&lt;/code&gt;, or null if none found.
     */
    public Colony getClosestColony(Stream&lt;Colony&gt; colonies) {
<span class="pc bnc" id="L2786" title="All 2 branches missed.">        ToIntFunction&lt;Colony&gt; closeness = c -&gt; (c == null) ? MANY_TURNS-1</span>
<span class="nc" id="L2787">            : this.getTurnsToReach(c);</span>
<span class="fc" id="L2788">        return Stream.concat(Stream.of((Colony)null), colonies)</span>
<span class="fc" id="L2789">            .collect(Collectors.minBy(Comparator.comparingInt(closeness)))</span>
<span class="fc" id="L2790">            .orElse(null);</span>
    }
    
    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2805">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2806" title="1 of 4 branches missed.">        if (player.getNumberOfSettlements() &lt;= 0 || !hasTile()) return null;</span>
<span class="fc" id="L2807">        return findOurNearestSettlement(getTile(), excludeStart,</span>
<span class="fc" id="L2808">                                        range, coastal);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @param startTile The &lt;code&gt;Tile&lt;/code&gt; to start searching from.
     * @param excludeStart If true, ignore any settlement the unit is
     *     currently in.
     * @param range An upper bound on the number of moves.
     * @param coastal If true, the settlement must have a path to Europe.
     * @return The nearest matching settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement(final Tile startTile,
                                             final boolean excludeStart,
                                             int range, final boolean coastal) {
<span class="fc" id="L2825">        final Player player = getOwner();</span>
<span class="pc bpc" id="L2826" title="1 of 2 branches missed.">        if (startTile == null</span>
<span class="pc bpc" id="L2827" title="1 of 2 branches missed.">            || player.getNumberOfSettlements() &lt;= 0) return null;</span>
<span class="fc" id="L2828">        final GoalDecider gd = new GoalDecider() {</span>

<span class="fc" id="L2830">                private int bestValue = Integer.MAX_VALUE;</span>
<span class="fc" id="L2831">                private PathNode best = null;</span>

                @Override
<span class="fc" id="L2834">                public PathNode getGoal() { return best; }</span>
                @Override
<span class="fc" id="L2836">                public boolean hasSubGoals() { return true; }</span>
                @Override
                public boolean check(Unit u, PathNode path) {
<span class="fc" id="L2839">                    Tile t = path.getTile();</span>
<span class="pc bpc" id="L2840" title="1 of 2 branches missed.">                    if (t == null</span>
<span class="pc bpc" id="L2841" title="1 of 4 branches missed.">                        || (t == startTile &amp;&amp; excludeStart)) return false;</span>
<span class="fc" id="L2842">                    Settlement settlement = t.getSettlement();</span>
                    int value;
<span class="fc bfc" id="L2844" title="All 2 branches covered.">                    if (settlement != null</span>
<span class="pc bpc" id="L2845" title="1 of 2 branches missed.">                        &amp;&amp; player.owns(settlement)</span>
<span class="pc bpc" id="L2846" title="1 of 4 branches missed.">                        &amp;&amp; (!coastal || settlement.isConnectedPort())</span>
<span class="fc bfc" id="L2847" title="All 2 branches covered.">                        &amp;&amp; (value = path.getTotalTurns()) &lt; bestValue) {</span>
<span class="fc" id="L2848">                        bestValue = value;</span>
<span class="fc" id="L2849">                        best = path;</span>
<span class="fc" id="L2850">                        return true;</span>
                    }
<span class="fc" id="L2852">                    return false;</span>
                }
            };
<span class="fc" id="L2855">        return search(startTile, gd, CostDeciders.avoidIllegal(), range, null);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier.
     *
     * @return A path to the nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestSettlement() {
<span class="fc" id="L2865">        return findOurNearestSettlement(false, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier and is connected to
     * Europe by sea, or Europe if it is closer.
     *
     * @return A path to the nearest settlement if any, otherwise null
     *     (for now including if in Europe or at sea).
     */
    public PathNode findOurNearestPort() {
<span class="fc" id="L2877">        PathNode ePath = null;</span>
<span class="fc" id="L2878">        int eTurns = -1;</span>
<span class="fc" id="L2879">        Europe europe = getOwner().getEurope();</span>
<span class="pc bpc" id="L2880" title="1 of 2 branches missed.">        if (getType().canMoveToHighSeas()) {</span>
<span class="pc bpc" id="L2881" title="1 of 2 branches missed.">            ePath = (europe == null) ? null : findPath(europe);</span>
<span class="fc bfc" id="L2882" title="All 2 branches covered.">            eTurns = (ePath == null) ? -1 : ePath.getTotalTurns();</span>
        }
<span class="fc" id="L2884">        PathNode sPath = findOurNearestSettlement(false, INFINITY, true);</span>
<span class="fc bfc" id="L2885" title="All 2 branches covered.">        int sTurns = (sPath == null) ? -1 : sPath.getTotalTurns();</span>
<span class="fc bfc" id="L2886" title="All 2 branches covered.">        return (ePath == null) ? sPath</span>
<span class="fc bfc" id="L2887" title="All 2 branches covered.">            : (sPath == null) ? ePath</span>
<span class="pc bpc" id="L2888" title="1 of 2 branches missed.">            : (sTurns &lt;= eTurns) ? sPath : ePath;</span>
    }

    /**
     * Find a path to a settlement nearer to a destination.
     *
     * Used to find where to deliver goods to/from inland colonies,
     * or when blocked.
     *
     * @param dst The destination &lt;code&gt;Location&lt;/code&gt;.
     * @return A path to the port, or null if none found.
     */
    public PathNode findIntermediatePort(Location dst) {
<span class="nc" id="L2901">        final Settlement ignoreSrc = getSettlement();</span>
<span class="nc" id="L2902">        final Settlement ignoreDst = dst.getSettlement();</span>
<span class="nc" id="L2903">        final Tile srcTile = getTile();</span>
<span class="nc" id="L2904">        final Tile dstTile = dst.getTile();</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">        final int dstCont = (dstTile == null) ? -1 : dstTile.getContiguity();</span>
<span class="nc" id="L2906">        PathNode path, best = null;</span>
<span class="nc" id="L2907">        int value, bestValue = INFINITY;</span>
        int type;

<span class="nc bnc" id="L2910" title="All 2 branches missed.">        if (isNaval()) {</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">            if (!srcTile.isHighSeasConnected()) {</span>
                // On a lake!  FIXME: do better
<span class="nc" id="L2913">                type = 0;</span>
<span class="nc bnc" id="L2914" title="All 2 branches missed.">            } else if (dstTile == null) {</span>
                // Carrier must be blocked from high seas
<span class="nc" id="L2916">                type = 1;</span>
<span class="nc bnc" id="L2917" title="All 2 branches missed.">            } else if (dstTile.isHighSeasConnected()) {</span>
                // Carrier is blocked or destination is blocked.
<span class="nc bnc" id="L2919" title="All 2 branches missed.">                type = (getTile().isOnRiver()) ? 1 : 2;</span>
<span class="nc" id="L2920">            } else {</span>
                // Destination must be blocked
<span class="nc" id="L2922">                type = 2;</span>
            }
<span class="nc" id="L2924">        } else {</span>
<span class="nc bnc" id="L2925" title="All 4 branches missed.">            if (dstTile == null || getTile().getContiguity() != dstCont) {</span>
                // Ocean travel will be required
                // If already at port try to improve its connectivity,
                // otherwise go to a port.
<span class="nc bnc" id="L2929" title="All 2 branches missed.">                type = (srcTile.isHighSeasConnected()) ? 1 : 2;</span>
<span class="nc" id="L2930">            } else {</span>
                // Pure land travel, just find a nearer settlement.
<span class="nc" id="L2932">                type = 3;</span>
            }
        }

<span class="nc bnc" id="L2936" title="All 5 branches missed.">        switch (type) {</span>
        case 0:
            // No progress possible.
<span class="nc" id="L2939">            break;</span>
        case 1:
            // Starting on a river, probably blocked in there.
            // Find the settlement that most reduces the high seas count.
<span class="nc" id="L2943">            best = search(getLocation(),</span>
<span class="nc" id="L2944">                          GoalDeciders.getReduceHighSeasCountGoalDecider(this),</span>
<span class="nc" id="L2945">                          null, INFINITY, null);</span>
<span class="nc" id="L2946">            break;</span>
        case 2:
            // Ocean travel required, destination blocked.
            // Find the closest available connected port.
<span class="nc bnc" id="L2950" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L2951" title="All 6 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst &amp;&amp; s.isConnectedPort()</span>
<span class="nc bnc" id="L2952" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L2953">                    value = path.getTotalTurns()</span>
<span class="nc" id="L2954">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L2955" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L2956">                        bestValue = value;</span>
<span class="nc" id="L2957">                        best = path;</span>
                    }
                }
            }
<span class="nc" id="L2961">            break;</span>
        case 3:
            // Land travel.  Find nearby settlement with correct contiguity.
<span class="nc bnc" id="L2964" title="All 2 branches missed.">            for (Settlement s : getOwner().getSettlements()) {</span>
<span class="nc bnc" id="L2965" title="All 4 branches missed.">                if (s != ignoreSrc &amp;&amp; s != ignoreDst</span>
<span class="nc bnc" id="L2966" title="All 2 branches missed.">                    &amp;&amp; s.getTile().getContiguity() == dstCont</span>
<span class="nc bnc" id="L2967" title="All 2 branches missed.">                    &amp;&amp; (path = findPath(s)) != null) {</span>
<span class="nc" id="L2968">                    value = path.getTotalTurns()</span>
<span class="nc" id="L2969">                        + dstTile.getDistanceTo(s.getTile());</span>
<span class="nc bnc" id="L2970" title="All 2 branches missed.">                    if (bestValue &gt; value) {</span>
<span class="nc" id="L2971">                        bestValue = value;</span>
<span class="nc" id="L2972">                        best = path;</span>
                    }
                }
            }
        }
<span class="nc bnc" id="L2977" title="All 2 branches missed.">        return (best != null) ? best</span>
<span class="nc" id="L2978">            : findOurNearestSettlement(false, INFINITY, false);</span>
    }

    /**
     * Find a path for this unit to the nearest settlement with the
     * same owner that is reachable without a carrier, excepting any
     * on the current tile.
     *
     * @return The nearest settlement if any, otherwise null.
     */
    public PathNode findOurNearestOtherSettlement() {
<span class="nc" id="L2989">        return findOurNearestSettlement(true, Integer.MAX_VALUE, false);</span>
    }

    /**
     * Convenience wrapper for the
     * {@link net.sf.freecol.common.model.Map#search} function.
     *
     * @param start The &lt;code&gt;Location&lt;/code&gt; to start the search from.
     * @param gd The object responsible for determining whether a
     *     given &lt;code&gt;PathNode&lt;/code&gt; is a goal or not.
     * @param cd An optional &lt;code&gt;CostDecider&lt;/code&gt;
     *     responsible for determining the path cost.
     * @param maxTurns The maximum number of turns the given
     *     &lt;code&gt;Unit&lt;/code&gt; is allowed to move. This is the
     *     maximum search range for a goal.
     * @param carrier An optional naval carrier &lt;code&gt;Unit&lt;/code&gt; to use.
     * @return The path to a goal, or null if none can be found.
     */
    public PathNode search(Location start, GoalDecider gd,
                           CostDecider cd, int maxTurns, Unit carrier) {
<span class="pc bpc" id="L3009" title="1 of 2 branches missed.">        return (start == null) ? null</span>
<span class="fc" id="L3010">            : getGame().getMap().search(this, start, gd, cd, maxTurns,</span>
<span class="fc" id="L3011">                                        carrier, null);</span>
    }

    /**
     * Can this unit attack a specified defender?
     *
     * A naval unit can never attack a land unit or settlement,
     * but a land unit *can* attack a naval unit if it is beached.
     * Otherwise naval units can only fight at sea, land units
     * only on land.
     *
     * @param defender The defending &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can attack.
     */
    public boolean canAttack(Unit defender) {
<span class="pc bpc" id="L3026" title="2 of 4 branches missed.">        if (!isOffensiveUnit() || defender == null</span>
<span class="pc bpc" id="L3027" title="1 of 2 branches missed.">            || !defender.hasTile()) return false;</span>

<span class="fc" id="L3029">        Tile tile = defender.getTile();</span>
<span class="pc bpc" id="L3030" title="1 of 2 branches missed.">        return (isNaval())</span>
<span class="nc bnc" id="L3031" title="All 4 branches missed.">            ? !tile.hasSettlement() &amp;&amp; defender.isNaval()</span>
<span class="pc bpc" id="L3032" title="3 of 4 branches missed.">            : !defender.isNaval() || defender.isBeached();</span>
    }

    /**
     * Searches for a unit that is a credible threatening unit to this
     * unit within a range.
     *
     * @param range The number of turns to search for a threat in.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return A path to the threat, or null if not found.
     */
    public PathNode searchForDanger(final int range, final float threat) {
<span class="nc" id="L3045">        final CombatModel cm = getGame().getCombatModel();</span>
<span class="nc" id="L3046">        final Tile start = getTile();</span>
<span class="nc" id="L3047">        final GoalDecider threatDecider = new GoalDecider() {</span>
<span class="nc" id="L3048">                private PathNode found = null;</span>

                @Override
<span class="nc" id="L3051">                public PathNode getGoal() { return found; }</span>
                @Override
<span class="nc" id="L3053">                public boolean hasSubGoals() { return false; }</span>
                @Override
                public boolean check(Unit unit, PathNode path) {
<span class="nc" id="L3056">                    Tile tile = path.getTile();</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">                    if (tile == null) return false;</span>
<span class="nc" id="L3058">                    Unit first = tile.getFirstUnit();</span>
<span class="nc bnc" id="L3059" title="All 2 branches missed.">                    if (first == null</span>
<span class="nc bnc" id="L3060" title="All 2 branches missed.">                        || !getOwner().atWarWith(first.getOwner())) {</span>
<span class="nc" id="L3061">                        return false;</span>
                    }
<span class="nc bnc" id="L3063" title="All 2 branches missed.">                    for (Unit u : tile.getUnitList()) {</span>
                        PathNode reverse;
<span class="nc bnc" id="L3065" title="All 2 branches missed.">                        if (u.canAttack(unit)</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">                            &amp;&amp; cm.calculateCombatOdds(u, unit).win &gt;= threat</span>
<span class="nc bnc" id="L3067" title="All 2 branches missed.">                            &amp;&amp; (reverse = u.findPath(start)) != null</span>
<span class="nc bnc" id="L3068" title="All 2 branches missed.">                            &amp;&amp; reverse.getTotalTurns() &lt; range) {</span>
<span class="nc" id="L3069">                            found = path;</span>
<span class="nc" id="L3070">                            return true;</span>
                        }
                    }
<span class="nc" id="L3073">                    return false;</span>
                }
            };
        // The range to search will depend on the speed of the other
        // unit.  We can not know what it will be in advance, and it
        // might be significantly faster than this unit.  We do not
        // want to just use an unbounded search range because this
        // routine must be quick (especially when the supplied range
        // is low).  So use the heuristic of increasing the range by
        // the ratio of the fastest appropriate (land/naval) unit type
        // speed over the unit speed.
<span class="nc bnc" id="L3084" title="All 2 branches missed.">        int reverseRange = range * (((isNaval())</span>
<span class="nc" id="L3085">                ? getSpecification().getFastestNavalUnitType()</span>
<span class="nc" id="L3086">                : getSpecification().getFastestLandUnitType())</span>
<span class="nc" id="L3087">            .getMovement()) / this.getType().getMovement();</span>

<span class="nc bnc" id="L3089" title="All 2 branches missed.">        return (start == null) ? null</span>
<span class="nc" id="L3090">            : search(start, threatDecider, CostDeciders.avoidIllegal(),</span>
<span class="nc" id="L3091">                     reverseRange, getCarrier());</span>
    }

    /**
     * Checks if there is a credible threatening unit to this unit
     * within a range of moves.
     *
     * @param range The number of turns to search for a threat within.
     * @param threat The maximum tolerable probability of a potentially
     *            threatening unit defeating this unit in combat.
     * @return True if a threat was found.
     */
    public boolean isInDanger(int range, float threat) {
<span class="nc bnc" id="L3104" title="All 2 branches missed.">        return searchForDanger(range, threat) != null;</span>
    }

    /**
     * Gets the line of sight of this &lt;code&gt;Unit&lt;/code&gt;.  That is the
     * distance this &lt;code&gt;Unit&lt;/code&gt; can sight new tiles.
     *
     * @return The line of sight of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public int getLineOfSight() {
<span class="fc" id="L3114">        final Turn turn = getGame().getTurn();</span>
<span class="fc" id="L3115">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="fc" id="L3116">        result.addAll(this.getModifiers(Modifier.LINE_OF_SIGHT_BONUS,</span>
<span class="fc" id="L3117">                                        unitType, turn));</span>
<span class="pc bpc" id="L3118" title="1 of 4 branches missed.">        if (hasTile() &amp;&amp; getTile().isExplored()) {</span>
<span class="fc" id="L3119">            result.addAll(getTile().getType()</span>
<span class="fc" id="L3120">                .getModifiers(Modifier.LINE_OF_SIGHT_BONUS, unitType, turn));</span>
        }
<span class="fc" id="L3122">        float base = unitType.getLineOfSight();</span>
<span class="fc" id="L3123">        return (int)applyModifiers(base, turn, result);</span>
    }


    // Goods handling

    /**
     * Get the goods carried by this unit.
     *
     * @return A list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getGoodsList() {
<span class="pc bpc" id="L3135" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3136">            : getGoodsContainer().getGoods();</span>
    }

    /**
     * Get a compact version of the goods carried by this unit.
     *
     * @return A compact list of &lt;code&gt;Goods&lt;/code&gt;.
     */
    public List&lt;Goods&gt; getCompactGoodsList() {
<span class="pc bpc" id="L3145" title="1 of 2 branches missed.">        return (getGoodsContainer() == null) ? Collections.&lt;Goods&gt;emptyList()</span>
<span class="fc" id="L3146">            : getGoodsContainer().getCompactGoods();</span>
    }

    /**
     * Can this unit carry other units?
     *
     * @return True if the unit can carry units.
     */
    public boolean canCarryUnits() {
<span class="fc" id="L3155">        return hasAbility(Ability.CARRY_UNITS);</span>
    }

    /**
     * Could this unit carry a specified one?
     * This ignores the current load.
     *
     * @param u The potential cargo &lt;code&gt;Unit&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Unit u) {
<span class="pc bpc" id="L3166" title="1 of 4 branches missed.">        return canCarryUnits()</span>
<span class="fc" id="L3167">            &amp;&amp; getCargoCapacity() &gt;= u.getSpaceTaken();</span>
    }

    /**
     * Can this unit carry goods.
     *
     * @return True if the unit can carry goods.
     */
    public boolean canCarryGoods() {
<span class="fc" id="L3176">        return hasAbility(Ability.CARRY_GOODS);</span>
    }

    /**
     * Could this unit carry some specified goods?
     * This ignores the current load.
     *
     * @param g The potential cargo &lt;code&gt;Goods&lt;/code&gt;.
     * @return True if this unit can carry the cargo.
     */
    public boolean couldCarry(Goods g) {
<span class="pc bpc" id="L3187" title="2 of 4 branches missed.">        return canCarryGoods()</span>
<span class="fc" id="L3188">            &amp;&amp; getCargoCapacity() &gt;= g.getSpaceTaken();</span>
    }

    /**
     * Gets the number of free cargo slots left on this unit.
     *
     * @return The number of free cargo slots on this unit.
     */
    public int getSpaceLeft() {
<span class="fc" id="L3197">        return getCargoCapacity() - getCargoSpaceTaken();</span>
    }

    /**
     * Is there free space left on this unit?
     *
     * @return True if there is free space.
     */
    public boolean hasSpaceLeft() {
<span class="fc bfc" id="L3206" title="All 2 branches covered.">        return getSpaceLeft() &gt; 0;</span>
    }

    /**
     * Gets the total space this unit has to carry cargo.
     *
     * @return The total space.
     */
    public int getCargoCapacity() {
<span class="fc" id="L3215">        return unitType.getSpace();</span>
    }

    /**
     * Gets the space occupied by goods in this unit.  Must defend
     * against goods container being null as this can be called in the
     * client on foreign units, which will not have goods containers.
     *
     * @return The number cargo slots occupied by goods.
     */
    public int getGoodsSpaceTaken() {
<span class="pc bpc" id="L3226" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3227">        GoodsContainer gc = getGoodsContainer();</span>
<span class="pc bpc" id="L3228" title="1 of 2 branches missed.">        return (gc == null) ? 0 : gc.getSpaceTaken();</span>
    }

    /**
     * Gets the space occupied by units in this unit.
     *
     * @return The number of cargo slots occupied by units.
     */
    public int getUnitSpaceTaken() {
<span class="fc bfc" id="L3237" title="All 2 branches covered.">        return (canCarryUnits())</span>
<span class="fc" id="L3238">            ? getUnitList().stream().mapToInt(u -&gt; u.getSpaceTaken()).sum()</span>
<span class="fc" id="L3239">            : 0;</span>
    }

    /**
     * Gets the space occupied by cargo in this unit (both goods and units).
     *
     * @return The number of occupied cargo slots.
     */
    public int getCargoSpaceTaken() {
<span class="fc" id="L3248">        return getGoodsSpaceTaken() + getUnitSpaceTaken();</span>
    }

    /**
     * Is this unit carrying any goods cargo?
     *
     * @return True if the unit is carrying any goods cargo.
     */
    public boolean hasGoodsCargo() {
<span class="fc bfc" id="L3257" title="All 2 branches covered.">        return getGoodsSpaceTaken() &gt; 0;</span>
    }

    /**
     * Is this unit carrying any cargo (goods or unit).
     *
     * @return True if the unit is carrying any cargo.
     */
    public boolean hasCargo() {
<span class="nc bnc" id="L3266" title="All 2 branches missed.">        return getCargoSpaceTaken() &gt; 0;</span>
    }

    /**
     * Gets the extra amount of a specified type of goods that could
     * be loaded onto this unit.  Includes empty cargo slots and any
     * spare space in a slot partially filled with the specified
     * goods.
     *
     * @param type The &lt;code&gt;GoodsType&lt;/code&gt; to examine.
     * @return The amount of goods that could be loaded onto this unit.
     */
    public int getLoadableAmount(GoodsType type) {
<span class="pc bpc" id="L3279" title="1 of 2 branches missed.">        if (!canCarryGoods()) return 0;</span>
<span class="fc" id="L3280">        int result = getSpaceLeft() * GoodsContainer.CARGO_SIZE;</span>
<span class="fc" id="L3281">        int count = getGoodsCount(type) % GoodsContainer.CARGO_SIZE;</span>
<span class="fc bfc" id="L3282" title="All 2 branches covered.">        if (count != 0) result += GoodsContainer.CARGO_SIZE - count;</span>
<span class="fc" id="L3283">        return result;</span>
    }


    // Miscellaneous more complex functionality

    /**
     * Get a label for the current unit occupation.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; viewing the unit, as the
     *     owner has access to more information.
     * @param full If true, return a more detailed result.
     * @return A &lt;code&gt;StringTemplate&lt;/code&gt; for the unit occupation.
     */
    public StringTemplate getOccupationLabel(Player player, boolean full) {
<span class="fc" id="L3298">        final TradeRoute tradeRoute = getTradeRoute();</span>
        StringTemplate ret;
<span class="pc bpc" id="L3300" title="1 of 4 branches missed.">        if (player != null &amp;&amp; player.owns(this)) {</span>
<span class="fc bfc" id="L3301" title="All 2 branches covered.">            if (isDamaged()) {</span>
<span class="pc bpc" id="L3302" title="1 of 2 branches missed.">                if (full) {</span>
<span class="fc" id="L3303">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="fc" id="L3304">                        .add(&quot;model.unit.occupation.underRepair&quot;)</span>
<span class="fc" id="L3305">                        .addName(String.valueOf(getTurnsForRepair()));</span>
<span class="fc" id="L3306">                } else {</span>
<span class="nc" id="L3307">                    ret = StringTemplate.key(&quot;model.unit.occupation.underRepair&quot;);</span>
                }
<span class="pc bfc" id="L3309" title="All 2 branches covered.">            } else if (tradeRoute != null) {</span>
<span class="pc bpc" id="L3310" title="1 of 2 branches missed.">                if (full) {</span>
<span class="fc" id="L3311">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="fc" id="L3312">                        .add(&quot;model.unit.occupation.inTradeRoute&quot;)</span>
<span class="fc" id="L3313">                        .addName(tradeRoute.getName());</span>
<span class="fc" id="L3314">                } else {</span>
<span class="nc" id="L3315">                    ret = StringTemplate.key(&quot;model.unit.occupation.inTradeRoute&quot;);</span>
                }
<span class="pc bpc" id="L3317" title="3 of 4 branches missed.">            } else if (getState() == UnitState.ACTIVE &amp;&amp; getMovesLeft() == 0) {</span>
<span class="nc" id="L3318">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
<span class="pc bpc" id="L3319" title="1 of 2 branches missed.">            } else if (getState() == UnitState.IMPROVING</span>
<span class="pc bpc" id="L3320" title="1 of 2 branches missed.">                &amp;&amp; getWorkImprovement() != null) {</span>
<span class="pc bpc" id="L3321" title="1 of 2 branches missed.">                if (full) {</span>
<span class="fc" id="L3322">                    ret = StringTemplate.label(&quot;:&quot;)</span>
<span class="fc" id="L3323">                        .add(getWorkImprovement().getType() + &quot;.occupationString&quot;)</span>
<span class="fc" id="L3324">                        .addName(String.valueOf(getWorkTurnsLeft()));</span>
<span class="fc" id="L3325">                } else {</span>
<span class="nc" id="L3326">                    ret = StringTemplate.key(getWorkImprovement().getType() + &quot;.occupationString&quot;);</span>
                }
<span class="nc bnc" id="L3328" title="All 2 branches missed.">            } else if (getDestination() != null) {</span>
<span class="nc" id="L3329">                ret = StringTemplate.key(&quot;model.unit.occupation.goingSomewhere&quot;);</span>
<span class="nc" id="L3330">            } else {</span>
<span class="nc" id="L3331">                ret = StringTemplate.key(&quot;model.unit.&quot; + getState().getKey());</span>
            }
<span class="nc" id="L3333">        } else {</span>
<span class="pc bpc" id="L3334" title="1 of 2 branches missed.">            if (isNaval()) {</span>
<span class="nc" id="L3335">                ret = StringTemplate.name(String.valueOf(getVisibleGoodsCount()));</span>
<span class="nc" id="L3336">            } else {</span>
<span class="fc" id="L3337">                ret = StringTemplate.key(&quot;model.unit.occupation.activeNoMovesLeft&quot;);</span>
            }
        }
<span class="fc" id="L3340">        return ret;</span>
    }

    /**
     * Gets the probability that an attack by this unit will provoke a
     * native to convert.
     *
     * @return A probability of conversion.
     */
    public float getConvertProbability() {
<span class="fc" id="L3350">        final Specification spec = getSpecification();</span>
<span class="fc" id="L3351">        int opt = spec.getInteger(GameOptions.NATIVE_CONVERT_PROBABILITY);</span>
<span class="fc" id="L3352">        return 0.01f * applyModifiers(opt, getGame().getTurn(),</span>
<span class="fc" id="L3353">                                      Modifier.NATIVE_CONVERT_BONUS);</span>
    }

    /**
     * Gets the probability that an attack by this unit will provoke natives
     * to burn our missions.
     *
     * FIXME: enhance burn probability proportionally with tension
     *
     * @return A probability of burning missions.
     */
    public float getBurnProbability() {
<span class="nc" id="L3365">        final Specification spec = getSpecification();</span>
<span class="nc" id="L3366">        return 0.01f * spec.getInteger(GameOptions.BURN_PROBABILITY);</span>
    }

    /**
     * Get a type change for this unit.
     *
     * @param change The &lt;code&gt;ChangeType&lt;/code&gt; to consider.
     * @param owner The &lt;code&gt;Player&lt;/code&gt; to own this unit after a
     *    change of type CAPTURE or UNDEAD.
     * @return The resulting unit type or null if there is no change suitable.
     */
    public UnitType getTypeChange(ChangeType change, Player owner) {
<span class="fc" id="L3378">        return getType().getTargetType(change, owner);</span>
    }

    /**
     * Checks if the treasure train can be cashed in at it's current
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain() {
<span class="fc" id="L3389">        return canCashInTreasureTrain(getLocation());</span>
    }

    /**
     * Checks if the treasure train can be cashed in at the given
     * &lt;code&gt;Location&lt;/code&gt;.
     *
     * @param loc The &lt;code&gt;Location&lt;/code&gt;.
     * @return &lt;code&gt;true&lt;/code&gt; if the treasure train can be cashed in.
     * @exception IllegalStateException if this unit is not a treasure train.
     */
    public boolean canCashInTreasureTrain(Location loc) {
<span class="pc bpc" id="L3401" title="1 of 2 branches missed.">        if (!canCarryTreasure()) {</span>
<span class="nc" id="L3402">            throw new IllegalStateException(&quot;Can't carry treasure&quot;);</span>
        }
<span class="fc bfc" id="L3404" title="All 2 branches covered.">        if (loc == null) return false;</span>

<span class="pc bpc" id="L3406" title="1 of 2 branches missed.">        if (getOwner().getEurope() == null) {</span>
            // Any colony will do once independent, as the treasure stays
            // in the New World.
<span class="nc bnc" id="L3409" title="All 2 branches missed.">            return loc.getColony() != null;</span>
        }
<span class="fc bfc" id="L3411" title="All 2 branches covered.">        if (loc.getColony() != null) {</span>
            // Cash in if at a colony which has connectivity to Europe
            // unless the player has a suitable carrier and no free transport.
<span class="fc bfc" id="L3414" title="All 2 branches covered.">            return loc.getColony().isConnectedPort()</span>
<span class="fc bfc" id="L3415" title="All 2 branches covered.">                &amp;&amp; (getOwner().getCarriersForUnit(this).isEmpty()</span>
<span class="pc bpc" id="L3416" title="1 of 2 branches missed.">                    || getTransportFee() == 0);</span>
        }
        // Otherwise, cash in if in Europe.
<span class="pc bpc" id="L3419" title="1 of 2 branches missed.">        return loc instanceof Europe</span>
<span class="pc bpc" id="L3420" title="1 of 4 branches missed.">            || (loc instanceof Unit &amp;&amp; ((Unit)loc).isInEurope());</span>
    }

    /**
     * Get the fee that would have to be paid to transport this
     * treasure to Europe.
     *
     * @return The fee required for transport.
     */
    public int getTransportFee() {
<span class="pc bpc" id="L3430" title="1 of 4 branches missed.">        if (!isInEurope() &amp;&amp; getOwner().getEurope() != null) {</span>
<span class="fc" id="L3431">            float fee = (getSpecification()</span>
<span class="fc" id="L3432">                .getInteger(GameOptions.TREASURE_TRANSPORT_FEE)</span>
<span class="fc" id="L3433">                * getTreasureAmount()) / 100.0f;</span>
<span class="fc" id="L3434">            return (int)getOwner().applyModifiers(fee, getGame().getTurn(),</span>
<span class="fc" id="L3435">                Modifier.TREASURE_TRANSPORT_FEE, unitType);</span>
        }
<span class="fc" id="L3437">        return 0;</span>
    }

    /**
     * Gets the skill level.
     *
     * @return The level of skill for this unit.  A higher value
     *     signals a more advanced type of units.
     */
    public int getSkillLevel() {
<span class="fc" id="L3447">        return getSkillLevel(unitType);</span>
    }

    /**
     * Gets the skill level of the given type of &lt;code&gt;Unit&lt;/code&gt;.
     *
     * @param unitType The type of &lt;code&gt;Unit&lt;/code&gt;.
     * @return The level of skill for the given unit.  A higher value
     *     signals a more advanced type of units.
     */
    public static int getSkillLevel(UnitType unitType) {
<span class="pc bpc" id="L3458" title="1 of 2 branches missed.">        return (unitType.hasSkill()) ? unitType.getSkill() : 0;</span>
    }

    /**
     * Gets the appropriate trade bonuses due to a missionary unit.
     *
     * @param sense The sense to apply the modifiers.
     * @return The missionary trade bonuses.
     */
    public Set&lt;Modifier&gt; getMissionaryTradeModifiers(boolean sense) {
<span class="nc" id="L3468">        HashSet&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3469" title="All 2 branches missed.">        for (Modifier m : getModifiers(Modifier.MISSIONARY_TRADE_BONUS)) {</span>
<span class="nc" id="L3470">            Modifier modifier = new Modifier(m);</span>
<span class="nc bnc" id="L3471" title="All 2 branches missed.">            if (!sense) modifier.setValue(-m.getValue());</span>
<span class="nc" id="L3472">            result.add(modifier);</span>
        }
<span class="nc" id="L3474">        return result;</span>
    }

    /**
     * Adds a feature to the Unit.  This method always throws an
     * &lt;code&gt;UnsupportedOperationException&lt;/code&gt;, since features can
     * not be added to Units directly.
     *
     * @param feature The &lt;code&gt;Feature&lt;/code&gt; to add.
     */
    public void addFeature(Feature feature) {
<span class="nc" id="L3485">        throw new UnsupportedOperationException(&quot;Can not add Feature to Unit directly!&quot;);</span>
    }

    /**
     * Gets the &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     *
     * FIXME: the input parameter is ignored! Fix?
     *
     * @param input A list of input &lt;code&gt;AbstractGoods&lt;/code&gt;.
     * @return The &lt;code&gt;ProductionInfo&lt;/code&gt; for this unit.
     */
    public ProductionInfo getProductionInfo(List&lt;AbstractGoods&gt; input) {
<span class="fc" id="L3497">        ProductionInfo result = new ProductionInfo();</span>
<span class="fc" id="L3498">        result.setConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3499">        result.setMaximumConsumption(getType().getConsumedGoods());</span>
<span class="fc" id="L3500">        return result;</span>
    }

    /**
     * Score this unit with its suitability for pioneering.
     *
     * A pioneer must be a colonst.  Favour:
     * - existing pioneers especially if on the map
     * - expert pioneer units
     * - then by skill but not other experts
     *
     * @return A pioneering score.
     */
    public int getPioneerScore() {
<span class="nc bnc" id="L3514" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3515" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3516" title="All 2 branches missed.">            : (hasAbility(Ability.IMPROVE_TERRAIN)) ? 900 + ht</span>
<span class="nc bnc" id="L3517" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_PIONEER)) ? 700</span>
<span class="nc bnc" id="L3518" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">            : (getSkillLevel() &gt; 0) ? 0</span>
<span class="nc" id="L3520">            : 200 + getSkillLevel() * 50;</span>
    }

    /**
     * Score this unit with its suitability for scouting.
     *
     * A scout must be a colonist.  Favour:
     * - existing scouts especially if on the map
     * - expert scouts
     * - lower skill level as scouting is a good career for crims and servants
     *   which might become seasoned scouts
     *
     * @return A scouting score.
     */
    public int getScoutScore() {
<span class="nc bnc" id="L3535" title="All 2 branches missed.">        int ht = (hasTile()) ? 100 : 0;</span>
<span class="nc bnc" id="L3536" title="All 4 branches missed.">        return (getLocation() == null || !isColonist()) ? -1000</span>
<span class="nc bnc" id="L3537" title="All 2 branches missed.">            : (hasAbility(Ability.SPEAK_WITH_CHIEF)) ? 900 + ht</span>
<span class="nc bnc" id="L3538" title="All 2 branches missed.">            : (hasAbility(Ability.EXPERT_SCOUT)) ? 700</span>
<span class="nc bnc" id="L3539" title="All 2 branches missed.">            : (!hasDefaultRole()) ? 0</span>
<span class="nc bnc" id="L3540" title="All 2 branches missed.">            : (getSkillLevel() &lt;= 0) ? -200 * getSkillLevel()</span>
<span class="nc" id="L3541">            : 0;</span>
    }

    /**
     * Evaluate this unit for trade purposes.
     *
     * @param player The &lt;code&gt;Player&lt;/code&gt; to evaluate for.
     * @return A value of this unit.
     */
    public int evaluateFor(Player player) {
<span class="nc" id="L3551">        final Europe europe = player.getEurope();</span>
<span class="nc bnc" id="L3552" title="All 4 branches missed.">        if (player.isAI() &amp;&amp; player.getUnits().size() &lt; 10) {</span>
<span class="nc" id="L3553">            return Integer.MIN_VALUE;</span>
        }
<span class="nc bnc" id="L3555" title="All 2 branches missed.">        return (europe == null) ? 500 : europe.getUnitPrice(getType());</span>
    }

    // @compat 0.11.0
    /**
     * Get modifiers required for combat.
     *
     * This can be replaced with just getModifiers() when accepted
     * specifications have all combat modifiers with correct index
     * values.
     */
    public Set&lt;Modifier&gt; getCombatModifiers(String id,
        FreeColGameObjectType fcgot, Turn turn) {
<span class="fc" id="L3568">        final Player owner = getOwner();</span>
<span class="fc" id="L3569">        final UnitType unitType = getType();</span>
<span class="fc" id="L3570">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc bfc" id="L3573" title="All 2 branches covered.">        for (Modifier m : unitType.getModifiers(id, fcgot, turn)) {</span>
<span class="fc bfc" id="L3574" title="All 2 branches covered.">            switch (m.getType()) {</span>
            case ADDITIVE:
<span class="fc" id="L3576">                m.setModifierIndex(Modifier.UNIT_ADDITIVE_COMBAT_INDEX);</span>
<span class="fc" id="L3577">                break;</span>
            default:
<span class="fc" id="L3579">                m.setModifierIndex(Modifier.UNIT_NORMAL_COMBAT_INDEX);</span>
                break;
            }
<span class="fc" id="L3582">            result.add(m);</span>
        }

        // The player's modifiers may not all apply
<span class="fc bfc" id="L3586" title="All 2 branches covered.">        for (Modifier m : owner.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3587">            m.setModifierIndex(Modifier.GENERAL_COMBAT_INDEX);</span>
<span class="fc" id="L3588">            result.add(m);</span>
        }
        
        // Role modifiers apply
<span class="fc bfc" id="L3592" title="All 2 branches covered.">        for (Modifier m : role.getModifiers(id, fcgot, turn)) {</span>
<span class="fc" id="L3593">            m.setModifierIndex(Modifier.ROLE_COMBAT_INDEX);</span>
<span class="fc" id="L3594">            result.add(m);</span>
        }

<span class="fc" id="L3597">        return result;</span>
    }
    // end @compat 0.11.0


    // Message unpacking support.

    /**
     * Gets the tile in a given direction.
     *
     * @param directionString The direction.
     * @return The &lt;code&gt;Tile&lt;/code&gt; in the given direction.
     * @throws IllegalStateException if there is trouble.
     */
    public Tile getNeighbourTile(String directionString) {
<span class="nc bnc" id="L3612" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3613">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3614">                + getId());</span>
        }

<span class="nc" id="L3617">        Direction direction = Enum.valueOf(Direction.class, directionString);</span>
<span class="nc" id="L3618">        Tile tile = getTile().getNeighbourOrNull(direction);</span>
<span class="nc bnc" id="L3619" title="All 2 branches missed.">        if (tile == null) {</span>
<span class="nc" id="L3620">            throw new IllegalStateException(&quot;Could not find tile&quot;</span>
<span class="nc" id="L3621">                + &quot; in direction: &quot; + direction + &quot; from unit: &quot; + getId());</span>
        }
<span class="nc" id="L3623">        return tile;</span>
    }

    /**
     * Get a settlement by identifier, validating as much as possible.
     * Designed for message unpacking where the identifier should not
     * be trusted.
     *
     * @param settlementId The identifier of the
     *     &lt;code&gt;Settlement&lt;/code&gt; to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public Settlement getAdjacentSettlementSafely(String settlementId)
        throws IllegalStateException {
<span class="nc" id="L3639">        Game game = getOwner().getGame();</span>

<span class="nc" id="L3641">        Settlement settlement = game.getFreeColGameObject(settlementId,</span>
<span class="nc" id="L3642">                                                          Settlement.class);</span>
<span class="nc bnc" id="L3643" title="All 2 branches missed.">        if (settlement == null) {</span>
<span class="nc" id="L3644">            throw new IllegalStateException(&quot;Not a settlement: &quot;</span>
<span class="nc" id="L3645">                + settlementId);</span>
<span class="nc bnc" id="L3646" title="All 2 branches missed.">        } else if (settlement.getTile() == null) {</span>
<span class="nc" id="L3647">            throw new IllegalStateException(&quot;Settlement is not on the map: &quot;</span>
<span class="nc" id="L3648">                + settlementId);</span>
        }

<span class="nc bnc" id="L3651" title="All 2 branches missed.">        if (!hasTile()) {</span>
<span class="nc" id="L3652">            throw new IllegalStateException(&quot;Unit is not on the map: &quot;</span>
<span class="nc" id="L3653">                + getId());</span>
<span class="nc bnc" id="L3654" title="All 2 branches missed.">        } else if (getTile().getDistanceTo(settlement.getTile()) &gt; 1) {</span>
<span class="nc" id="L3655">            throw new IllegalStateException(&quot;Unit &quot; + getId()</span>
<span class="nc" id="L3656">                + &quot; is not adjacent to settlement: &quot; + settlementId);</span>
<span class="nc bnc" id="L3657" title="All 2 branches missed.">        } else if (getOwner() == settlement.getOwner()) {</span>
<span class="nc" id="L3658">            throw new IllegalStateException(&quot;Unit: &quot; + getId()</span>
<span class="nc" id="L3659">                + &quot; and settlement: &quot; + settlementId</span>
<span class="nc" id="L3660">                + &quot; are both owned by player: &quot; + getOwner().getId());</span>
        }

<span class="nc" id="L3663">        return settlement;</span>
    }

    /**
     * Get an adjacent Indian settlement by identifier, validating as
     * much as possible, including checking whether the nation
     * involved has been contacted.  Designed for message unpacking
     * where the identifier should not be trusted.
     *
     * @param id The identifier of the &lt;code&gt;IndianSettlement&lt;/code&gt;
     *     to be found.
     * @return The settlement corresponding to the settlementId argument.
     * @throws IllegalStateException on failure to validate the settlementId
     *     in any way.
     */
    public IndianSettlement getAdjacentIndianSettlementSafely(String id)
        throws IllegalStateException {
<span class="nc" id="L3680">        Settlement settlement = getAdjacentSettlementSafely(id);</span>
<span class="nc bnc" id="L3681" title="All 2 branches missed.">        if (!(settlement instanceof IndianSettlement)) {</span>
<span class="nc" id="L3682">            throw new IllegalStateException(&quot;Not an indianSettlement: &quot; + id);</span>
<span class="nc bnc" id="L3683" title="All 2 branches missed.">        } else if (!getOwner().hasContacted(settlement.getOwner())) {</span>
<span class="nc" id="L3684">            throw new IllegalStateException(&quot;Player has not contacted the &quot;</span>
<span class="nc" id="L3685">                + settlement.getOwner().getNation());</span>
        }

<span class="nc" id="L3688">        return (IndianSettlement)settlement;</span>
    }


    // Interface Consumer

    /**
     * {@inheritDoc}
     */
    @Override
    public List&lt;AbstractGoods&gt; getConsumedGoods() {
<span class="fc" id="L3699">        return unitType.getConsumedGoods();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getPriority() {
<span class="fc" id="L3707">        return unitType.getPriority();</span>
    }


    // Interface Ownable

    /**
     * {@inheritDoc}
     */
    @Override
    public Player getOwner() {
<span class="fc" id="L3718">        return owner;</span>
    }

    /**
     * {@inheritDoc}
     *
     * -vis: This routine has visibility implications.
     */
    @Override
    public void setOwner(Player player) {
<span class="fc" id="L3728">        this.owner = player;</span>
<span class="fc" id="L3729">    }</span>


    // Interface Locatable
    //   getTile and getSpaceTaken are shared with Location below

    /**
     * Gets the location of this unit.
     *
     * @return The location of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    @Override
    public Location getLocation() {
<span class="fc" id="L3742">        return location;</span>
    }

    /**
     * Sets the location of this unit.
     *
     * -vis: This routine changes player visibility.
     * -til: While units do not contribute to tile appearance as such, if
     *     they move in/out of a colony the visible colony size changes.
     *
     * @param newLocation The new &lt;code&gt;Location&lt;/code&gt;.
     * @return True if the location change succeeds.
     */
    @Override
    public boolean setLocation(Location newLocation) {
        // It is possible to add a unit to a non-specific location
        // within a colony by specifying the colony as the new
        // location.  Colony.joinColony handles this special case.
<span class="fc bfc" id="L3760" title="All 2 branches covered.">        if (newLocation instanceof Colony) {</span>
<span class="fc" id="L3761">            return ((Colony)newLocation).joinColony(this);</span>
        }

<span class="fc bfc" id="L3764" title="All 2 branches covered.">        if (newLocation == location) return true;</span>
<span class="fc bfc" id="L3765" title="All 4 branches covered.">        if (newLocation != null &amp;&amp; !newLocation.canAdd(this)) {</span>
<span class="fc" id="L3766">            logger.warning(&quot;Can not add &quot; + this + &quot; to &quot;</span>
<span class="fc" id="L3767">                + newLocation.getId());</span>
<span class="fc" id="L3768">            return false;</span>
        }

        // If the unit either starts or ends this move in a colony
        // then teaching status can change.  However, if it moves
        // between locations within the same colony with the same
        // teaching ability, the teaching state should *not* change.
        // We have to handle this issue here in setLocation as this is
        // the only place that contains information about both
        // locations.
<span class="fc bfc" id="L3778" title="All 2 branches covered.">        Colony oldColony = (isInColony()) ? location.getColony() : null;</span>
<span class="fc bfc" id="L3779" title="All 2 branches covered.">        Colony newColony = (newLocation instanceof WorkLocation)</span>
<span class="fc" id="L3780">            ? newLocation.getColony() : null;</span>
<span class="fc bfc" id="L3781" title="All 4 branches covered.">        boolean withinColony = newColony != null &amp;&amp; newColony == oldColony;</span>
<span class="fc bfc" id="L3782" title="All 2 branches covered.">        boolean preserveEducation = withinColony</span>
<span class="fc" id="L3783">            &amp;&amp; (((WorkLocation)location).canTeach()</span>
<span class="fc bfc" id="L3784" title="All 2 branches covered.">                == ((WorkLocation)newLocation).canTeach());</span>

        // First disable education that will fail due to the move.
<span class="fc bfc" id="L3787" title="All 4 branches covered.">        if (oldColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3788">            oldColony.updateEducation(this, false);</span>
        }

        // Move out of the old location.
<span class="fc" id="L3792">        setLocationMoveFromOldLocation();</span>

        // Move in to the new location.
<span class="fc" id="L3795">        setLocationMoveToNewLocation(newLocation);</span>

        // See if education needs to be re-enabled.
<span class="fc bfc" id="L3798" title="All 4 branches covered.">        if (newColony != null &amp;&amp; !preserveEducation) {</span>
<span class="fc" id="L3799">            newColony.updateEducation(this, true);</span>
        }

        // Update population of any colonies involved.
<span class="fc" id="L3803">        setLocationUpdatePopulation(oldColony, newColony, withinColony);</span>
<span class="fc" id="L3804">        return true;</span>
    }

	private void setLocationMoveFromOldLocation() {
<span class="fc bfc" id="L3808" title="All 2 branches covered.">		if (location == null) {</span>
            ; // do nothing
<span class="pc bpc" id="L3810" title="1 of 2 branches missed.">        } else if (!location.remove(this)) {//-vis</span>
            // &quot;Should not happen&quot; (should always be able to remove)
<span class="nc" id="L3812">            throw new RuntimeException(&quot;Failed to remove &quot; + this</span>
<span class="nc" id="L3813">                + &quot; from &quot; + location.getId());</span>
        }
<span class="fc" id="L3815">	}</span>

	private void setLocationMoveToNewLocation(Location newLocation) {
<span class="fc bfc" id="L3818" title="All 2 branches covered.">		if (newLocation == null) {</span>
<span class="fc" id="L3819">            setLocationNoUpdate(null);//-vis</span>
<span class="pc bpc" id="L3820" title="1 of 2 branches missed.">        } else if (!newLocation.add(this)) {//-vis</span>
            // &quot;Should not happen&quot; (canAdd was checked above)
<span class="nc" id="L3822">            throw new RuntimeException(&quot;Failed to add &quot;</span>
<span class="nc" id="L3823">                + this + &quot; to &quot; + newLocation.getId());</span>
        }
<span class="fc" id="L3825">	}</span>

	private void setLocationUpdatePopulation(Colony oldColony, Colony newColony, boolean withinColony) {
<span class="fc bfc" id="L3828" title="All 2 branches covered.">		if (!withinColony) {</span>
<span class="fc bfc" id="L3829" title="All 2 branches covered.">            if (oldColony != null) oldColony.updatePopulation();</span>
<span class="fc bfc" id="L3830" title="All 2 branches covered.">            if (newColony != null) newColony.updatePopulation();</span>
        }
<span class="fc" id="L3832">	}</span>

    /**
     * Checks if this &lt;code&gt;Unit&lt;/code&gt; is located in Europe.  That
     * is; either directly or onboard a carrier which is in Europe.
     *
     * @return True if in &lt;code&gt;Europe&lt;/code&gt;.
     */
    @Override
    public boolean isInEurope() {
<span class="fc bfc" id="L3842" title="All 2 branches covered.">        return (location instanceof Unit) ? ((Unit)location).isInEurope()</span>
<span class="fc" id="L3843">            : getLocation() instanceof Europe;</span>
    }


    // Interface Location (from GoodsLocation via UnitLocation)
    // Inherits
    //   FreeColObject.getId
    //   UnitLocation.getLocationLabelFor
    //   UnitLocation.contains
    //   UnitLocation.canAdd
    //   UnitLocation.getUnitCount
    //   UnitLocation.getUnitList
    //   GoodsLocation.getGoodsContainer

    /**
     * {@inheritDoc}
     */
    @Override
    public Tile getTile() {
<span class="fc bfc" id="L3862" title="All 2 branches covered.">        return (location != null) ? location.getTile() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public StringTemplate getLocationLabel() {
<span class="nc" id="L3870">        return StringTemplate.template(&quot;model.unit.onBoard&quot;)</span>
<span class="nc" id="L3871">            .addStringTemplate(&quot;%unit%&quot;, this.getLabel());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean add(Locatable locatable) {
<span class="fc bfc" id="L3879" title="All 2 branches covered.">        if (!canAdd(locatable)) {</span>
<span class="fc" id="L3880">            return false;</span>
<span class="fc bfc" id="L3881" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="fc" id="L3882">            Unit unit = (Unit)locatable;</span>
<span class="pc bpc" id="L3883" title="1 of 2 branches missed.">            if (super.add(locatable)) {</span>
                // FIXME: there seems to be an inconsistency between
                // units moving from an adjacent tile onto a ship and
                // units boarding a ship in-colony.  The former does not
                // appear to come through here (which it probably should)
                // as the ship's moves do not get zeroed.
<span class="fc" id="L3889">                spendAllMoves();</span>
<span class="fc" id="L3890">                unit.setState(UnitState.SENTRY);</span>
<span class="fc" id="L3891">                return true;</span>
            }
<span class="pc bpc" id="L3893" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L3894">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L3895" title="1 of 2 branches missed.">            if (super.addGoods(goods)) {</span>
<span class="fc" id="L3896">                spendAllMoves();</span>
<span class="fc" id="L3897">                return true;</span>
            }
        } else {
<span class="nc" id="L3900">            throw new IllegalStateException(&quot;Can not be added to unit: &quot;</span>
<span class="nc" id="L3901">                + locatable);</span>
        }
<span class="nc" id="L3903">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean remove(Locatable locatable) {
<span class="pc bpc" id="L3911" title="1 of 2 branches missed.">        if (locatable == null) {</span>
<span class="nc" id="L3912">            throw new IllegalArgumentException(&quot;Locatable must not be 'null'.&quot;);</span>
<span class="pc bpc" id="L3913" title="2 of 4 branches missed.">        } else if (locatable instanceof Unit &amp;&amp; canCarryUnits()) {</span>
<span class="pc bpc" id="L3914" title="1 of 2 branches missed.">            if (super.remove(locatable)) {</span>
<span class="fc" id="L3915">                spendAllMoves();</span>
<span class="fc" id="L3916">                return true;</span>
            }
<span class="nc bnc" id="L3918" title="All 4 branches missed.">        } else if (locatable instanceof Goods &amp;&amp; canCarryGoods()) {</span>
<span class="nc bnc" id="L3919" title="All 2 branches missed.">            if (super.removeGoods((Goods)locatable) != null) {</span>
<span class="nc" id="L3920">                spendAllMoves();</span>
<span class="nc" id="L3921">                return true;</span>
            }
        } else {
<span class="nc" id="L3924">            logger.warning(&quot;Tried to remove from unit: &quot;</span>
<span class="nc" id="L3925">                + locatable);</span>
        }
<span class="nc" id="L3927">        return false;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Settlement getSettlement() {
<span class="fc" id="L3935">        Location location = getLocation();</span>
<span class="fc bfc" id="L3936" title="All 2 branches covered.">        return (location != null) ? location.getSettlement() : null;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Location up() {
<span class="nc bnc" id="L3944" title="All 2 branches missed.">        return (isInEurope()) ? getLocation().up()</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">            : (isInColony()) ? getColony()</span>
<span class="nc bnc" id="L3946" title="All 2 branches missed.">            : (hasTile()) ? getTile().up()</span>
<span class="nc" id="L3947">            : this;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getRank() {
<span class="fc" id="L3955">        return Location.getRank(getLocation());</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toShortString() {
<span class="fc" id="L3963">        StringBuilder sb = new StringBuilder(32);</span>
<span class="fc" id="L3964">        sb.append(getId()).append(&quot;-&quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L3965" title="All 2 branches covered.">        if (!hasDefaultRole()) {</span>
<span class="fc" id="L3966">            sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L3967">            int count = getRoleCount();</span>
<span class="fc bfc" id="L3968" title="All 2 branches covered.">            if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
        }
<span class="fc" id="L3970">        return sb.toString();</span>
    }


    // UnitLocation
    // Inherits
    //   UnitLocation.getSpaceTaken
    //   UnitLocation.moveToFront
    //   UnitLocation.clearUnitList

    /**
     * {@inheritDoc}
     */
    @Override
    public int getSpaceTaken() {
        // We do not have to consider what this unit is carrying
        // because carriers can not be put onto carriers.  Yet.
<span class="fc" id="L3987">        return unitType.getSpaceTaken();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public NoAddReason getNoAddReason(Locatable locatable) {
<span class="fc bfc" id="L3995" title="All 2 branches covered.">        if (locatable == this) {</span>
<span class="fc" id="L3996">            return NoAddReason.ALREADY_PRESENT;</span>
<span class="fc bfc" id="L3997" title="All 2 branches covered.">        } else if (locatable instanceof Unit) {</span>
<span class="pc bpc" id="L3998" title="1 of 2 branches missed.">            return (!canCarryUnits())</span>
<span class="nc" id="L3999">                ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4000" title="All 2 branches covered.">                : (locatable.getSpaceTaken() &gt; getSpaceLeft())</span>
<span class="fc" id="L4001">                ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="fc" id="L4002">                : super.getNoAddReason(locatable);</span>
<span class="pc bpc" id="L4003" title="1 of 2 branches missed.">        } else if (locatable instanceof Goods) {</span>
<span class="fc" id="L4004">            Goods goods = (Goods)locatable;</span>
<span class="pc bpc" id="L4005" title="1 of 2 branches missed.">            return (!canCarryGoods())</span>
<span class="nc" id="L4006">                ? NoAddReason.WRONG_TYPE</span>
<span class="fc bfc" id="L4007" title="All 2 branches covered.">                : (goods.getAmount() &gt; getLoadableAmount(goods.getType()))</span>
<span class="fc" id="L4008">                ? NoAddReason.CAPACITY_EXCEEDED</span>
<span class="fc" id="L4009">                : NoAddReason.NONE;</span>
            // Do not call super.getNoAddReason for goods because
            // the capacity test in GoodsLocation.getNoAddReason does not
            // account for packing and is thus too conservative.
        }
<span class="nc" id="L4014">        return super.getNoAddReason(locatable);</span>
    }


    // GoodsLocation
    // Inherits
    //   GoodsLocation.addGoods
    //   GoodsLocation.removeGoods

    /**
     * {@inheritDoc}
     */
    @Override
    public int getGoodsCapacity() {
<span class="nc" id="L4028">        return getCargoCapacity();</span>
    }


    // Override FreeColGameObject

    /**
     * {@inheritDoc}
     *
     * -vis: This routine can change player visibility.
     */
    @Override
    public void disposeResources() {
<span class="fc bfc" id="L4041" title="All 2 branches covered.">        if (location != null) {</span>
<span class="fc" id="L4042">            location.remove(this);</span>
            // Do not set location to null, units that are slaughtered in
            // battle need to remain valid during the animation.
        }

<span class="pc bpc" id="L4047" title="1 of 2 branches missed.">        if (teacher != null) {</span>
<span class="nc" id="L4048">            teacher.setStudent(null);</span>
<span class="nc" id="L4049">            teacher = null;</span>
        }

<span class="pc bpc" id="L4052" title="1 of 2 branches missed.">        if (student != null) {</span>
<span class="nc" id="L4053">            student.setTeacher(null);</span>
<span class="nc" id="L4054">            student = null;</span>
        }

<span class="fc" id="L4057">        setHomeIndianSettlement(null);</span>

<span class="fc" id="L4059">        getOwner().removeUnit(this);</span>

<span class="fc" id="L4061">        super.disposeResources();</span>
<span class="fc" id="L4062">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public FreeColGameObject getLinkTarget(Player player) {
<span class="nc bnc" id="L4069" title="All 2 branches missed.">        return (hasTile()) ? (FreeColGameObject)getTile().up()</span>
<span class="nc" id="L4070">            : player.getEurope();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int checkIntegrity(boolean fix) {
<span class="fc" id="L4078">        int result = super.checkIntegrity(fix);</span>
<span class="fc bfc" id="L4079" title="All 2 branches covered.">        if (this.role == null) {</span>
<span class="pc bpc" id="L4080" title="1 of 2 branches missed.">            if (fix) {</span>
<span class="fc" id="L4081">                this.role = getSpecification().getDefaultRole();</span>
<span class="fc" id="L4082">                logger.warning(&quot;Fixed missing role for: &quot; + getId());</span>
<span class="fc" id="L4083">                result = 0;</span>
<span class="fc" id="L4084">            } else {</span>
<span class="nc" id="L4085">                logger.warning(&quot;Missing role for: &quot; + getId());</span>
<span class="nc" id="L4086">                result = -1;</span>
            }
        }
<span class="fc bfc" id="L4089" title="All 2 branches covered.">        if (this.destination != null) {</span>
<span class="pc bpc" id="L4090" title="1 of 2 branches missed.">            if (((FreeColGameObject)this.destination).isUninitialized()) {</span>
<span class="nc bnc" id="L4091" title="All 2 branches missed.">                if (fix) {</span>
<span class="nc" id="L4092">                    this.destination = null;</span>
<span class="nc" id="L4093">                    logger.warning(&quot;Cleared uninitialized destination for: &quot;</span>
<span class="nc" id="L4094">                        + getId());</span>
<span class="nc" id="L4095">                    result = Math.min(result, 0);</span>
<span class="nc" id="L4096">                } else {</span>
<span class="nc" id="L4097">                    logger.warning(&quot;Uninitialized destination for: &quot;</span>
<span class="nc" id="L4098">                        + getId());</span>
<span class="nc" id="L4099">                    result = -1;</span>
                }
            }
        }
<span class="fc" id="L4103">        return result;</span>
    }


    // Override FreeColObject

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Ability&gt; getAbilities(String id, FreeColGameObjectType fcgot,
                                     Turn turn) {
<span class="fc" id="L4115">        final Player owner = getOwner();</span>
<span class="fc" id="L4116">        final UnitType unitType = getType();</span>
<span class="fc" id="L4117">        Set&lt;Ability&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType abilities always apply.
<span class="fc" id="L4120">        result.addAll(unitType.getAbilities(id));</span>

        // Roles apply with qualification.
<span class="fc" id="L4123">        result.addAll(role.getAbilities(id, fcgot, turn));</span>

        // The player's abilities require more qualification.
<span class="fc" id="L4126">        result.addAll(owner.getAbilities(id, fcgot, turn));</span>

        // Location abilities may apply.
        // FIXME: extend this to all locations?  May simplify
        // code.  Units are also Locations however, which complicates
        // the issue as we do not want Units aboard other Units to share
        // the abilities of the carriers.
<span class="fc bfc" id="L4133" title="All 2 branches covered.">        if (getSettlement() != null) {</span>
<span class="fc" id="L4134">            result.addAll(getSettlement().getAbilities(id, unitType, turn));</span>
<span class="fc bfc" id="L4135" title="All 2 branches covered.">        } else if (isInEurope()) {</span>
            // @compat 0.10.x
            // It makes sense here to do:
            //   Europe europe = owner.getEurope();
            // However while there is fixup code in readChildren that calls
            // this routine we can not rely on owner.europe being initialized
            // yet.  Hence the following:
<span class="fc" id="L4142">            Location loc = getLocation();</span>
<span class="fc bfc" id="L4143" title="All 2 branches covered.">            Europe europe = (loc instanceof Europe) ? (Europe)loc</span>
<span class="pc bpc" id="L4144" title="1 of 2 branches missed.">                : (loc instanceof Unit) ? (Europe)((Unit)loc).getLocation()</span>
<span class="nc" id="L4145">                : null;</span>
            // end @compat 0.10.x
<span class="fc" id="L4147">            result.addAll(europe.getAbilities(id, unitType, turn));</span>
        }
<span class="fc" id="L4149">        return result;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Set&lt;Modifier&gt; getModifiers(String id, FreeColGameObjectType fcgot,
                                      Turn turn) {
<span class="fc" id="L4158">        final Player owner = getOwner();</span>
<span class="fc" id="L4159">        final UnitType unitType = getType();</span>
<span class="fc" id="L4160">        Set&lt;Modifier&gt; result = new HashSet&lt;&gt;();</span>

        // UnitType modifiers always apply
<span class="fc" id="L4163">        result.addAll(unitType.getModifiers(id, fcgot, turn));</span>

        // The player's modifiers may not all apply
<span class="fc" id="L4166">        result.addAll(owner.getModifiers(id, fcgot, turn));</span>
        
        // Role modifiers apply
<span class="fc" id="L4169">        result.addAll(role.getModifiers(id, fcgot, turn));</span>

<span class="fc" id="L4171">        return result;</span>
    }


    // Serialization

    private static final String ATTRITION_TAG = &quot;attrition&quot;;
    private static final String COUNT_TAG = &quot;count&quot;;
    private static final String CURRENT_STOP_TAG = &quot;currentStop&quot;;
    private static final String DESTINATION_TAG = &quot;destination&quot;;
    private static final String ENTRY_LOCATION_TAG = &quot;entryLocation&quot;;
    private static final String ETHNICITY_TAG = &quot;ethnicity&quot;;
    private static final String EXPERIENCE_TAG = &quot;experience&quot;;
    private static final String EXPERIENCE_TYPE_TAG = &quot;experienceType&quot;;
    private static final String HIT_POINTS_TAG = &quot;hitPoints&quot;;
    private static final String INDIAN_SETTLEMENT_TAG = &quot;indianSettlement&quot;;
    private static final String LOCATION_TAG = &quot;location&quot;;
    private static final String MOVES_LEFT_TAG = &quot;movesLeft&quot;;
    private static final String NAME_TAG = &quot;name&quot;;
    private static final String NATIONALITY_TAG = &quot;nationality&quot;;
    private static final String OWNER_TAG = &quot;owner&quot;;
    private static final String ROLE_TAG = &quot;role&quot;;
    private static final String ROLE_COUNT_TAG = &quot;roleCount&quot;;
    private static final String STATE_TAG = &quot;state&quot;;
    private static final String STUDENT_TAG = &quot;student&quot;;
    private static final String TRADE_ROUTE_TAG = &quot;tradeRoute&quot;;
    private static final String TEACHER_TAG = &quot;teacher&quot;;
    private static final String TREASURE_AMOUNT_TAG = &quot;treasureAmount&quot;;
    private static final String TURNS_OF_TRAINING_TAG = &quot;turnsOfTraining&quot;;
    private static final String UNIT_TYPE_TAG = &quot;unitType&quot;;
    private static final String VISIBLE_GOODS_COUNT_TAG = &quot;visibleGoodsCount&quot;;
    private static final String WORK_LEFT_TAG = &quot;workLeft&quot;;
    private static final String WORK_TYPE_TAG = &quot;workType&quot;;
    // @compat 0.10.5
    private static final String OLD_UNITS_TAG = &quot;units&quot;;
    // end @compat
    // @compat 0.10.7
    private static final String OLD_HIT_POINTS_TAG = &quot;hitpoints&quot;;
    private static final String EQUIPMENT_TAG = &quot;equipment&quot;;
    /** The equipment this Unit carries.  Now subsumed into roles. */
<span class="fc" id="L4211">    private final TypeCountMap&lt;EquipmentType&gt; equipment</span>
<span class="fc" id="L4212">        = new TypeCountMap&lt;&gt;();</span>
    // end @compat 0.10.x
    // @compat 0.11.3
<span class="fc" id="L4215">    private static final String OLD_TILE_IMPROVEMENT_TAG = &quot;tileimprovement&quot;;</span>
    // end @compat 0.11.3


    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeAttributes(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc" id="L4224">        super.writeAttributes(xw);</span>

<span class="fc" id="L4226">        boolean full = xw.validFor(getOwner());</span>

<span class="fc bfc" id="L4228" title="All 2 branches covered.">        if (name != null) xw.writeAttribute(NAME_TAG, name);</span>

<span class="fc" id="L4230">        xw.writeAttribute(UNIT_TYPE_TAG, unitType);</span>

<span class="fc" id="L4232">        xw.writeAttribute(MOVES_LEFT_TAG, movesLeft);</span>

<span class="fc" id="L4234">        xw.writeAttribute(STATE_TAG, state);</span>

<span class="fc" id="L4236">        xw.writeAttribute(ROLE_TAG, role);</span>

<span class="fc" id="L4238">        xw.writeAttribute(ROLE_COUNT_TAG, roleCount);</span>

<span class="pc bpc" id="L4240" title="1 of 4 branches missed.">        if (!full &amp;&amp; hasAbility(Ability.PIRACY)) {</span>
            // Pirates do not disclose national characteristics.
<span class="nc" id="L4242">            xw.writeAttribute(OWNER_TAG, getGame().getUnknownEnemy());</span>

<span class="nc" id="L4244">        } else {</span>
<span class="fc" id="L4245">            xw.writeAttribute(OWNER_TAG, getOwner());</span>

<span class="fc bfc" id="L4247" title="All 2 branches covered.">            if (isPerson()) {</span>
                // Do not write out nationality and ethnicity for non-persons.
<span class="pc bpc" id="L4249" title="1 of 2 branches missed.">                xw.writeAttribute(NATIONALITY_TAG, (nationality != null)</span>
<span class="fc" id="L4250">                    ? nationality</span>
<span class="nc" id="L4251">                    : getOwner().getNationId());</span>

<span class="pc bpc" id="L4253" title="1 of 2 branches missed.">                xw.writeAttribute(ETHNICITY_TAG, (ethnicity != null)</span>
<span class="fc" id="L4254">                    ? ethnicity</span>
<span class="nc" id="L4255">                    : getOwner().getNationId());</span>
            }
        }

<span class="fc bfc" id="L4259" title="All 2 branches covered.">        if (location != null) {</span>
<span class="pc bpc" id="L4260" title="1 of 4 branches missed.">            if (!full &amp;&amp; isInColony()) {</span>
                // Really special case.  This happens in attack
                // animations when a defender unit is invisible
                // working inside a colony and has to be specially
                // serialized to the client.
<span class="nc" id="L4265">                xw.writeLocationAttribute(LOCATION_TAG, getColony());</span>

<span class="nc" id="L4267">            } else {</span>
<span class="fc" id="L4268">                xw.writeLocationAttribute(LOCATION_TAG, location);</span>
            }
        }

<span class="fc" id="L4272">        xw.writeAttribute(TREASURE_AMOUNT_TAG, treasureAmount);</span>

<span class="fc bfc" id="L4274" title="All 2 branches covered.">        if (full) {</span>
<span class="fc bfc" id="L4275" title="All 2 branches covered.">            if (entryLocation != null) {</span>
<span class="fc" id="L4276">                xw.writeLocationAttribute(ENTRY_LOCATION_TAG, entryLocation);</span>
            }

<span class="fc" id="L4279">            xw.writeAttribute(TURNS_OF_TRAINING_TAG, turnsOfTraining);</span>

<span class="fc bfc" id="L4281" title="All 2 branches covered.">            if (workType != null) xw.writeAttribute(WORK_TYPE_TAG, workType);</span>

<span class="fc bfc" id="L4283" title="All 2 branches covered.">            if (experienceType != null) {</span>
<span class="fc" id="L4284">                xw.writeAttribute(EXPERIENCE_TYPE_TAG, experienceType);</span>
            }

<span class="fc" id="L4287">            xw.writeAttribute(EXPERIENCE_TAG, experience);</span>

<span class="fc" id="L4289">            xw.writeAttribute(INDIAN_SETTLEMENT_TAG, indianSettlement);</span>

<span class="fc" id="L4291">            xw.writeAttribute(WORK_LEFT_TAG, workLeft);</span>

<span class="fc" id="L4293">            xw.writeAttribute(HIT_POINTS_TAG, hitPoints);</span>

<span class="fc" id="L4295">            xw.writeAttribute(ATTRITION_TAG, attrition);</span>

<span class="pc bpc" id="L4297" title="1 of 2 branches missed.">            if (student != null) xw.writeAttribute(STUDENT_TAG, student);</span>

<span class="pc bpc" id="L4299" title="1 of 2 branches missed.">            if (teacher != null) xw.writeAttribute(TEACHER_TAG, teacher);</span>

<span class="fc bfc" id="L4301" title="All 2 branches covered.">            if (destination != null) {</span>
<span class="fc" id="L4302">                xw.writeLocationAttribute(DESTINATION_TAG, destination);</span>
            }

<span class="pc bpc" id="L4305" title="1 of 2 branches missed.">            if (tradeRoute != null) {</span>
<span class="nc" id="L4306">                xw.writeAttribute(TRADE_ROUTE_TAG, tradeRoute);</span>

<span class="nc" id="L4308">                xw.writeAttribute(CURRENT_STOP_TAG, currentStop);</span>
            }
        }
<span class="fc" id="L4311">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void writeChildren(FreeColXMLWriter xw) throws XMLStreamException {
<span class="fc bfc" id="L4318" title="All 2 branches covered.">        if (xw.validFor(getOwner())) {</span>

            // Do not show goods or units carried by this unit.
<span class="fc" id="L4321">            super.writeChildren(xw);</span>

<span class="fc bfc" id="L4323" title="All 2 branches covered.">            if (workImprovement != null) workImprovement.toXML(xw);</span>

<span class="fc bfc" id="L4325" title="All 2 branches covered.">        } else if (getType().canCarryGoods()) {</span>
<span class="fc" id="L4326">            xw.writeAttribute(VISIBLE_GOODS_COUNT_TAG, getVisibleGoodsCount());</span>
        }
<span class="fc" id="L4328">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readAttributes(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4335">        super.readAttributes(xr);</span>

<span class="fc" id="L4337">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4338">        final Game game = getGame();</span>

<span class="fc" id="L4340">        name = xr.getAttribute(NAME_TAG, (String)null);</span>

<span class="fc" id="L4342">        Player oldOwner = owner;</span>
<span class="fc" id="L4343">        owner = xr.findFreeColGameObject(game, OWNER_TAG,</span>
<span class="fc" id="L4344">                                         Player.class, (Player)null, true);</span>
<span class="fc bfc" id="L4345" title="All 2 branches covered.">        if (xr.shouldIntern()) game.checkOwners(this, oldOwner);</span>

<span class="fc" id="L4347">        UnitType oldUnitType = unitType;</span>
<span class="fc" id="L4348">        unitType = xr.getType(spec, UNIT_TYPE_TAG,</span>
<span class="fc" id="L4349">                              UnitType.class, (UnitType)null);</span>

<span class="fc" id="L4351">        state = xr.getAttribute(STATE_TAG, UnitState.class, UnitState.ACTIVE);</span>

<span class="fc" id="L4353">        role = xr.getRole(spec, ROLE_TAG, Role.class,</span>
<span class="fc" id="L4354">                          spec.getDefaultRole());</span>
        // @compat 0.10.x
        // Fix roles
<span class="fc bfc" id="L4357" title="All 2 branches covered.">        if (owner.isIndian()) {</span>
<span class="pc bpc" id="L4358" title="1 of 2 branches missed.">            if (&quot;model.role.scout&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4359">                role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="pc bpc" id="L4360" title="1 of 2 branches missed.">            } else if (&quot;model.role.soldier&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4361">                role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="pc bpc" id="L4362" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4363">                role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
            }
<span class="pc bfc" id="L4365" title="All 2 branches covered.">        } else if (owner.isREF()) {</span>
<span class="pc bpc" id="L4366" title="1 of 2 branches missed.">            if (&quot;model.role.soldier&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4367" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4368">                role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="pc bpc" id="L4369" title="1 of 2 branches missed.">            } else if (&quot;model.role.dragoon&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4370" title="All 2 branches missed.">                &amp;&amp; unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4371">                role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="pc bpc" id="L4372" title="1 of 2 branches missed.">            } else if (&quot;model.role.infantry&quot;.equals(role.getId())</span>
<span class="nc bnc" id="L4373" title="All 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4374">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bpc" id="L4375" title="1 of 2 branches missed.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())</span>
<span class="pc bpc" id="L4376" title="1 of 2 branches missed.">                &amp;&amp; !unitType.hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4377">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
<span class="nc" id="L4379">        } else {</span>
<span class="pc bpc" id="L4380" title="1 of 2 branches missed.">            if (&quot;model.role.infantry&quot;.equals(role.getId())) {</span>
<span class="nc" id="L4381">                role = spec.getRole(&quot;model.role.soldier&quot;);</span>
<span class="pc bfc" id="L4382" title="All 2 branches covered.">            } else if (&quot;model.role.cavalry&quot;.equals(role.getId())) {</span>
<span class="fc" id="L4383">                role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
            }
        }            
        // end @compat 0.10.x

<span class="fc" id="L4388">        roleCount = xr.getAttribute(ROLE_COUNT_TAG,</span>
            // @compat 0.10.x
<span class="fc" id="L4390">            -1</span>
            // Should be role.getMaximumCount()
            // end @compat 0.10.x
            );

<span class="fc" id="L4395">        location = xr.getLocationAttribute(game, LOCATION_TAG, true);</span>

<span class="fc" id="L4397">        entryLocation = xr.getLocationAttribute(game, ENTRY_LOCATION_TAG,</span>
<span class="fc" id="L4398">                                                true);</span>

<span class="fc" id="L4400">        movesLeft = xr.getAttribute(MOVES_LEFT_TAG, 0);</span>

<span class="fc" id="L4402">        workLeft = xr.getAttribute(WORK_LEFT_TAG, 0);</span>

<span class="fc" id="L4404">        attrition = xr.getAttribute(ATTRITION_TAG, 0);</span>

<span class="fc" id="L4406">        nationality = xr.getAttribute(NATIONALITY_TAG, (String)null);</span>

<span class="fc" id="L4408">        ethnicity = xr.getAttribute(ETHNICITY_TAG, (String)null);</span>

<span class="fc" id="L4410">        turnsOfTraining = xr.getAttribute(TURNS_OF_TRAINING_TAG, 0);</span>

<span class="fc" id="L4412">        hitPoints = xr.getAttribute(HIT_POINTS_TAG, -1);</span>
        // @compat 0.10.7
<span class="pc bpc" id="L4414" title="1 of 2 branches missed.">        if (hitPoints &lt; 0) hitPoints = xr.getAttribute(OLD_HIT_POINTS_TAG, -1);</span>
        // end @compat

<span class="fc" id="L4417">        teacher = xr.makeFreeColGameObject(game, TEACHER_TAG,</span>
<span class="fc" id="L4418">                                           Unit.class, false);</span>

<span class="fc" id="L4420">        student = xr.makeFreeColGameObject(game, STUDENT_TAG,</span>
<span class="fc" id="L4421">                                           Unit.class, false);</span>

<span class="fc" id="L4423">        setHomeIndianSettlement(xr.makeFreeColGameObject(game,</span>
<span class="fc" id="L4424">                INDIAN_SETTLEMENT_TAG, IndianSettlement.class, false));</span>

<span class="fc" id="L4426">        treasureAmount = xr.getAttribute(TREASURE_AMOUNT_TAG, 0);</span>

<span class="fc" id="L4428">        destination = xr.getLocationAttribute(game, DESTINATION_TAG, true);</span>

<span class="fc" id="L4430">        tradeRoute = xr.findFreeColGameObject(game, TRADE_ROUTE_TAG,</span>
<span class="fc" id="L4431">            TradeRoute.class, (TradeRoute)null, false);</span>

<span class="pc bpc" id="L4433" title="1 of 2 branches missed.">        currentStop = (tradeRoute == null) ? -1</span>
<span class="nc" id="L4434">            : xr.getAttribute(CURRENT_STOP_TAG, 0);</span>

<span class="fc" id="L4436">        experienceType = xr.getType(spec, EXPERIENCE_TYPE_TAG,</span>
<span class="fc" id="L4437">                                    GoodsType.class, (GoodsType)null);</span>
<span class="pc bpc" id="L4438" title="1 of 4 branches missed.">        if (experienceType == null &amp;&amp; workType != null) {</span>
<span class="nc" id="L4439">            experienceType = workType;</span>
        }

<span class="fc" id="L4442">        experience = xr.getAttribute(EXPERIENCE_TAG, 0);</span>

<span class="fc" id="L4444">        visibleGoodsCount = xr.getAttribute(VISIBLE_GOODS_COUNT_TAG, -1);</span>

        // Make sure you do this after experience and location stuff.
<span class="fc" id="L4447">        changeWorkType(xr.getType(spec, WORK_TYPE_TAG, GoodsType.class, null));</span>
<span class="fc" id="L4448">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChildren(FreeColXMLReader xr) throws XMLStreamException {
        // Clear containers.
<span class="pc bpc" id="L4456" title="1 of 2 branches missed.">        if (getGoodsContainer() != null) getGoodsContainer().removeAll();</span>
<span class="fc" id="L4457">        equipment.clear();</span>
<span class="fc" id="L4458">        workImprovement = null;</span>

<span class="fc" id="L4460">        super.readChildren(xr);</span>

        // @compat 0.10.x
<span class="fc bfc" id="L4463" title="All 2 branches covered.">        if (roleCount &lt; 0) {</span>
            // If roleCount was not present, set it from equipment
<span class="fc" id="L4465">            readChildrenRoleCountLessThenZero();</span>
<span class="fc" id="L4466">        } else {</span>
            // If roleCount was present, we are now ignoring equipment.
<span class="fc" id="L4468">            equipment.clear();</span>
        }
        // end @compat 0.10.x

        // @compat 0.10.x
        // There was a bug in 0.10.x that did not clear tile
        // improvements after they were complete, leading to units
        // that still had a tile improvement after they had moved
        // away.  Consequently when reading such bogus improvements,
        // there is no guarantee that the tile is defined so
        // compatibility code in TileImprovement.readAttributes
        // tolerates null tile references.  These are obviously bogus,
        // so drop them.
<span class="pc bpc" id="L4481" title="3 of 4 branches missed.">        if (workImprovement != null &amp;&amp; workImprovement.getTile() == null) {</span>
<span class="nc" id="L4482">            workImprovement = null;</span>
        }
        // end @compat 0.10.x
<span class="fc" id="L4485">    }</span>

	private void readChildrenRoleCountLessThenZero() {
<span class="fc" id="L4488">		final Specification spec = getSpecification();</span>
<span class="fc" id="L4489">		Role role = spec.getDefaultRole();</span>
<span class="fc" id="L4490">		boolean horses = false, muskets = false;</span>
<span class="fc" id="L4491">		int count = 1;</span>
<span class="pc bpc" id="L4492" title="1 of 2 branches missed.">		for (EquipmentType type : equipment.keySet()) {</span>
<span class="nc bnc" id="L4493" title="All 2 branches missed.">		    if (&quot;model.equipment.horses&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4494" title="All 2 branches missed.">		        || &quot;model.equipment.indian.horses&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4495">		        horses = true;</span>
<span class="nc bnc" id="L4496" title="All 2 branches missed.">		    } else if (&quot;model.equipment.muskets&quot;.equals(type.getId())</span>
<span class="nc bnc" id="L4497" title="All 2 branches missed.">		        || &quot;model.equipment.indian.muskets&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4498">		        muskets = true;</span>
<span class="nc" id="L4499">		    } else {</span>
<span class="nc" id="L4500">		        role = type.getRole();</span>
<span class="nc bnc" id="L4501" title="All 2 branches missed.">		        if (&quot;model.equipment.tools&quot;.equals(type.getId())) {</span>
<span class="nc" id="L4502">		            count = equipment.getCount(type);</span>
		        }
		    }
		}
<span class="pc bpc" id="L4506" title="3 of 4 branches missed.">		if (horses &amp;&amp; muskets) {</span>
<span class="nc" id="L4507">		    role = getRoleThatHasHorsesAndMuskets(spec);</span>
<span class="pc bpc" id="L4508" title="1 of 2 branches missed.">		} else if (horses) {</span>
<span class="nc" id="L4509">		    role = getRoleThatHasHorses(spec, role);</span>
<span class="pc bpc" id="L4510" title="1 of 2 branches missed.">		} else if (muskets) {</span>
<span class="nc" id="L4511">		    role = getRoleThatHasMuskets(spec);</span>
		}
<span class="fc" id="L4513">		setRoleCount(Math.min(role.getMaximumCount(), count));</span>
<span class="fc" id="L4514">	}</span>

	private Role getRoleThatHasMuskets(final Specification spec) {
		Role role;
<span class="nc bnc" id="L4518" title="All 2 branches missed.">		if (owner.isIndian()) {</span>
<span class="nc" id="L4519">		    role = spec.getRole(&quot;model.role.armedBrave&quot;);</span>
<span class="nc bnc" id="L4520" title="All 4 branches missed.">		} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4521">		    role = spec.getRole(&quot;model.role.infantry&quot;);</span>
<span class="nc" id="L4522">		} else {</span>
<span class="nc" id="L4523">		    role = spec.getRole(&quot;model.role.soldier&quot;);</span>
		}
<span class="nc" id="L4525">		return role;</span>
	}

	private Role getRoleThatHasHorses(final Specification spec, Role role) {
<span class="nc bnc" id="L4529" title="All 2 branches missed.">		if (owner.isIndian()) {</span>
<span class="nc" id="L4530">		    role = spec.getRole(&quot;model.role.mountedBrave&quot;);</span>
<span class="nc bnc" id="L4531" title="All 4 branches missed.">		} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4532">		    logger.warning(&quot;Undefined role: REF Scout&quot;);</span>
<span class="nc" id="L4533">		} else {</span>
<span class="nc" id="L4534">		    role = spec.getRole(&quot;model.role.scout&quot;);</span>
		}
<span class="nc" id="L4536">		return role;</span>
	}

	private Role getRoleThatHasHorsesAndMuskets(final Specification spec) {
		Role role;
<span class="nc bnc" id="L4541" title="All 2 branches missed.">		if (owner.isIndian()) {</span>
<span class="nc" id="L4542">		    role = spec.getRole(&quot;model.role.nativeDragoon&quot;);</span>
<span class="nc bnc" id="L4543" title="All 4 branches missed.">		} else if (owner.isREF() &amp;&amp; hasAbility(Ability.REF_UNIT)) {</span>
<span class="nc" id="L4544">		    role = spec.getRole(&quot;model.role.cavalry&quot;);</span>
<span class="nc" id="L4545">		} else {</span>
<span class="nc" id="L4546">		    role = spec.getRole(&quot;model.role.dragoon&quot;);</span>
		}
<span class="nc" id="L4548">		return role;</span>
	}

    /**
     * {@inheritDoc}
     */
    @Override
    protected void readChild(FreeColXMLReader xr) throws XMLStreamException {
<span class="fc" id="L4556">        final Specification spec = getSpecification();</span>
<span class="fc" id="L4557">        final Game game = getGame();</span>
<span class="fc" id="L4558">        final String tag = xr.getLocalName();</span>

        // @compat 0.10.x
<span class="pc bpc" id="L4561" title="1 of 2 branches missed.">        if (EQUIPMENT_TAG.equals(tag)) {</span>
<span class="nc" id="L4562">            equipment.incrementCount(spec.getEquipmentType(xr.readId()),</span>
<span class="nc" id="L4563">                                     xr.getAttribute(COUNT_TAG, 0));</span>
<span class="nc" id="L4564">            xr.closeTag(EQUIPMENT_TAG);</span>
        // end @compat 0.10.x

        // @compat 0.10.5
<span class="pc bpc" id="L4568" title="1 of 2 branches missed.">        } else if (OLD_UNITS_TAG.equals(tag)) {</span>
<span class="nc bnc" id="L4569" title="All 2 branches missed.">            while (xr.nextTag() != XMLStreamConstants.END_ELEMENT) {</span>
<span class="nc" id="L4570">                super.readChild(xr);</span>
            }
        // end @compat 0.10.5

<span class="pc bpc" id="L4574" title="1 of 2 branches missed.">        } else if (TileImprovement.getXMLElementTagName().equals(tag)</span>
                   // @compat 0.11.3
<span class="pc bpc" id="L4576" title="1 of 2 branches missed.">                   || OLD_TILE_IMPROVEMENT_TAG.equals(tag)</span>
                   // end @compat 0.11.3
                   ) {
<span class="nc" id="L4579">            workImprovement = xr.readFreeColGameObject(game,</span>
<span class="nc" id="L4580">                                                       TileImprovement.class);</span>

<span class="nc" id="L4582">        } else {</span>
<span class="fc" id="L4583">            super.readChild(xr);</span>
        }
<span class="fc" id="L4585">    }</span>

    /**
     * Gets a string representation of this unit.
     *
     * @param prefix A prefix (e.g. &quot;AIUnit&quot;)
     * @return A string representation of this &lt;code&gt;Unit&lt;/code&gt;.
     */
    public String toString(String prefix) {
<span class="fc" id="L4594">        StringBuilder sb = new StringBuilder(64);</span>
<span class="fc" id="L4595">        sb.append(&quot;[&quot;).append(prefix).append(getId());</span>
<span class="pc bpc" id="L4596" title="1 of 2 branches missed.">        if (isUninitialized()) {</span>
<span class="nc" id="L4597">            sb.append(&quot; uninitialized&quot;);</span>
<span class="pc bpc" id="L4598" title="1 of 2 branches missed.">        } else if (isDisposed()) {</span>
<span class="nc" id="L4599">            sb.append(&quot; disposed&quot;);</span>
<span class="nc" id="L4600">        } else {</span>
<span class="fc" id="L4601">            sb.append(&quot; &quot;).append(lastPart(owner.getNationId(), &quot;.&quot;))</span>
<span class="fc" id="L4602">                .append(&quot; &quot;).append(getType().getSuffix());</span>
<span class="fc bfc" id="L4603" title="All 2 branches covered.">            if (!hasDefaultRole()) {</span>
<span class="fc" id="L4604">                sb.append(&quot;-&quot;).append(getRoleSuffix());</span>
<span class="fc" id="L4605">                int count = getRoleCount();</span>
<span class="pc bpc" id="L4606" title="1 of 2 branches missed.">                if (count &gt; 1) sb.append(&quot;.&quot;).append(count);</span>
            }
<span class="fc" id="L4608">            sb.append(&quot; &quot;).append(getMovesAsString());</span>
        }
<span class="fc" id="L4610">        sb.append(&quot;]&quot;);</span>
<span class="fc" id="L4611">        return sb.toString();</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String toString() {
<span class="fc" id="L4619">        return toString(&quot;&quot;);</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
<span class="fc" id="L4626">    public String getXMLTagName() { return getXMLElementTagName(); }</span>

    /**
     * Gets the tag name of the root element representing this object.
     *
     * @return &quot;unit&quot;
     */
    public static String getXMLElementTagName() {
<span class="fc" id="L4634">        return &quot;unit&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span>src (1) (May 16, 2018 4:05:44 PM)</div></body></html>